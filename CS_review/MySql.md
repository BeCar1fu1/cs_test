## 什么是SQL，什么是NoSQL?

SQL（Structed Query Language）结构化查询语句，它的核心思想是**数据以表格的形式存储，有固定的模式，**遵循ACID，保证数据的强一致性，使用SQL语句进行查询和操作。

而NoSQL数据库，他是非结构化或者半结构化的数据存储，它具有更灵活的shema（无固定资源）,可以水平扩展到分布式集群，具有高并发性和高可用性，通常是最终一致性，不支持复杂的事务。

## 请你简要说一下 InnoDB 和 MyISAM 两种存储引擎的主要区别。  

| 特性     | InnoDB              | MyISAM               |
| -------- | ------------------- | -------------------- |
| 事务支持 | 支持                | 不支持               |
| 外键     | 支持                | 不支持               |
| 锁机制   | 行级锁              | 表级锁               |
| 崩溃恢复 | 支持（有 redo log） | 不支持（恢复能力弱） |
| 默认引擎 | MySQL 5.5+ 默认引擎 | 否                   |
| 索引类型 | B+树（聚簇索引）    | B+树（非聚簇索引）   |

##  请你解释一下数据库的「事务」的四大特性（ACID）分别指什么？

- **Atomicity（原子性）：** 一个事务中的所有操作要么全部成功，要么全部失败回滚，不会停留在中间状态。
- **Consistency（一致性）：** 事务必须使数据库从一个一致性状态转移到另一个一致性状态，满足所有数据的完整性约束。
- **Isolation（隔离性）：** 并发事务之间相互隔离，一个事务的中间状态对其他事务不可见。
- **Durability（持久性）：** 一旦事务提交，其结果就是永久性的，即使系统崩溃也能保持。

###  请你解释一下 MySQL 的事务隔离级别有哪些？每一种隔离级别分别可能导致什么并发问题？  

| **隔离级别**                     | **脏读** | **不可重复读** | **幻读**                            |
| -------------------------------- | -------- | -------------- | ----------------------------------- |
| **Read Uncommitted（读未提交）** | ✅可能    | ✅可能          | ✅可能                               |
| **Read Committed（读已提交）**   | ❌避免    | ✅可能          | ✅可能                               |
| **Repeatable Read（可重复读）**  | ❌避免    | ❌避免          | ✅可能（但 InnoDB 已通过间隙锁解决） |
| **Serializable（串行化）**       | ❌避免    | ❌避免          | ❌避免                               |

###  请你解释一下 MySQL 中的索引种类有哪些？分别适用于什么场景？（至少说出三种）  

| 索引类型                        | 说明与用途                                                   |
| ------------------------------- | ------------------------------------------------------------ |
| **主键索引（Primary Key）**     | 表中唯一标识每条记录，不能重复且不能为空。在 InnoDB 中是聚簇索引。 |
| **唯一索引（Unique）**          | 用于保证字段的唯一性，如身份证号、邮箱等。允许为 `NULL`。    |
| **普通索引（Index）**           | 最常见的索引类型，没有唯一性约束，用于提高查询效率。         |
| **联合索引（Composite Index）** | 在多个字段上建立的索引，遵循最左前缀原则。                   |
| **全文索引（Fulltext）**        | 用于文本内容的搜索，常用于 `CHAR`, `VARCHAR`, `TEXT` 类型字段的模糊匹配。 |
| **空间索引（Spatial Index）**   | 用于地理空间数据类型（仅 MyISAM 支持较好）。                 |

###  请你说一说 InnoDB 中聚簇索引（Clustered Index）与非聚簇索引（Secondary Index）有什么区别？  

| 特性     | 聚簇索引（Clustered Index）  | 二级索引（Secondary Index）    |
| -------- | ---------------------------- | ------------------------------ |
| 存储结构 | B+树的**叶子节点存整行数据** | 叶子节点存**主键值（Row ID）** |
| 唯一性   | 必须唯一（通常是主键）       | 可唯一可非唯一                 |
| 查询效率 | 查询整行时效率高（无需回表） | 若查询字段不在索引中需回表     |
| 回表     | 无需回表                     | 需要根据主键回表查整行数据     |
| 举例     | `PRIMARY KEY(id)`            | `INDEX(name)` 等               |

###  MySQL 中创建索引有哪些原则？你在实际使用中会在什么情况下添加索引，又在什么情况下避免添加索引？  

1. **优先考虑高频查询字段建立索引。**对于经常出现在`where、orderby、groupby`条件中的列优先考虑建立索引。
2. **选择区分度高的字段建立索引。**字段的区分度越高，索引效率越高。
3. **尽量避免在索引列上使用函数或者表达式。**
4. **对数据量小或者频繁更新的表，慎重建索引。**因为建立索引会带来开销。

###  请你说一说 MySQL 中的覆盖索引（Covering Index）是什么？它能带来什么性能优势？是否所有查询都能使用覆盖索引？为什么？ 

**覆盖索引（Covering Index）是指一个查询所使用的索引包含了该查询所需要的所有字段**，因此查询时可以**仅通过索引结构完成数据的返回**，**不需要回表到聚簇索引中读取完整行数据**。   

✅ 覆盖索引的性能优势：

- 避免回表操作，减少磁盘 I/O；
- 提升查询效率，尤其在大表或频繁访问场景中；
- 可以配合执行计划判断是否使用（`EXPLAIN` 中 `Extra` 字段出现 `Using index` 即表示使用了覆盖索引）。

###  MySQL 中的事务隔离是如何通过 MVCC 实现的？请结合 `Read Committed` 和 `Repeatable Read` 两个隔离级别，说明 MVCC 的行为差异。  

MVCC（Multi-Version Concurrency Control）是 InnoDB 为了支持高并发下的**非阻塞读**而引入的一种机制。它通过维护每条记录的多个版本，使得读操作无需加锁，从而实现高并发。

✅ MVCC 的核心组成：

1. **undo log：**

- 每次对记录进行更新/删除时，会记录一份旧版本数据；
- 多个 undo log 构成一个“版本链”；
- 每条记录通过隐藏字段 `roll_pointer` 指向旧版本。

1. **ReadView：**

- 表示某个事务在某一时刻可见的数据快照；
- 包括当前系统中活跃事务 ID 列表，以及 min_id、max_id 等字段；
- 判断可见性的核心。

| **项目**             | **Read Committed**  | **Repeatable Read**        |
| -------------------- | ------------------- | -------------------------- |
| ReadView 创建时机    | 每条 SQL 语句执行时 | 第一次查询时               |
| 是否能重复读到不同值 | ✅可能               | ❌不可能                    |
| 幻读问题是否存在     | ✅存在               | ❌（InnoDB 中被间隙锁解决） |

### 请你简要介绍一下 InnoDB 中的 undo log 和 redo log 的区别和作用。为什么需要这两个日志？它们在事务提交过程中各自扮演什么角色？  

udolog日志的作用主要是在事务回滚时使用，另外一个就是支持MVCC的版本链控制，保证事务的原子性。记录一条数据修改前的旧值；存储在Innodb表空间中，写完的undolog先缓存在bufferpool的undo页中，等待后台线程进行刷盘，当事务提交并且旧版本不再被事务访问时，就可以清理。

redolog日志的作用主要是用于服务器的崩溃恢复，保证事务的持久化。记录的内容是xxx表空间的xxx数据页xxx偏移量的xxx更新。存储在logbuffer中，采用顺序写的方式进行持久化，当服务器崩溃时，能够进行快速的恢复，从而再使用undolog进行回滚等操作。他的存储文件名为ib_logfile1、ib_logfile2，两个文件构成环形空间进行写操作。

### 为什么不每次修改都直接写数据页到磁盘？

- 数据页通常比较大（例如 16KB），且磁盘写入是随机 I/O，速度慢；
- 每次更新都直接写入磁盘会极大拖慢事务执行速度；
- 数据页可能会被频繁修改，多次写入磁盘造成 **重复 I/O、浪费资源**；

### 为什么采用 redo log + WAL 机制？

**WAL（Write-Ahead Logging）机制的核心思想是：**

**先写日志，后写磁盘。**

1. 数据修改时，先将修改操作写入 redo log（顺序写，效率高）；
2. 只要 redo log 写入成功，就可以认为事务已经提交（持久性保障）；
3. 之后再将数据页“脏页”异步刷入磁盘，无需每次操作都立即落盘。

### MySQL 中执行 `UPDATE` 时，会经历哪些阶段？ 

1. **✅** **Server 层接收 SQL 并解析、优化**

- 查询语法、生成执行计划；
- 走到 InnoDB 引擎层准备执行。

1. **✅** **InnoDB 层执行修改操作：**

1. **Buffer Pool 查找页：**

1. InnoDB 通过主键或二级索引定位记录；
2. 若目标页不在内存中（Buffer Pool），则从磁盘加载该页。

1. **加锁：**

1. 加上对应行锁（或间隙锁），防止其他事务并发写入或读取不一致。

1. **写入 undo log：**

1. 将修改前的值写入 undo log，用于事务回滚或 MVCC 多版本并发控制。

1. **修改页内容（更新 age 字段）：**

1. 在 Buffer Pool 中修改该记录，修改的是内存页。

1. **标记为脏页：**

1. 被修改的页会标记为 dirty，等待刷回磁盘。

1. **写入 redo log：**

1. 将“页的某个位置被改动”的操作记录到 redo log（顺序写）；
2. 满足 WAL 机制（先写日志，再刷数据页）。

1. **✅** **事务提交（COMMIT）：**

- 执行两阶段提交（2PC）：

1. 写入 redo log 并 **写入磁盘（fsync）**；
2. 标记事务为已提交；
3. undo log 标记为可清理。

- 后台刷脏页：异步地将修改过的页从 Buffer Pool 刷回磁盘。

### MySQL 中为什么说二级索引更新代价比主键更新更高？更新二级索引列会带来哪些额外开销？请说明具体的触发操作与代价来源。

✅ 1. **更新主键列：**

更新主键本质上是修改了聚簇索引的**关键字**，因此：

- 旧主键那一行需要删除；
- 新主键重新插入一行；
- 并且还需要**更新所有引用了主键的二级索引** ⇒ 成本高！

✅ 2. **更新二级索引列：**

即使只是修改某个二级索引列（如 `name`），也会产生如下开销：

| **步骤**     | **原因**                                  |
| ------------ | ----------------------------------------- |
| 删除旧索引项 | 原二级索引值对应的索引项要删除            |
| 插入新索引项 | 新的索引值要插入到二级索引 B+ 树中        |
| 回表验证数据 | 若不是覆盖索引，查询时仍需回表查主键记录  |
| 重建索引项   | 因为二级索引存储的是（索引列值 + 主键值） |

所以，**更新涉及二级索引的字段，其实是在该索引 B+ 树上执行“删除+插入”操作**，这带来了磁盘 I/O 与页分裂、页合并等额外代价。

### Mysql查询很慢是什么原因？怎么解决？

- **通过EXPLAIN进行分析：**分析SQL的执行计划，查看是否使用了全表扫描，是否存在索引为被利用的情况？
- **创建或者优化索引：**根据查询条件创建合适的索引，特别是经常使用where子句的字段、Orderby的字段等，如果查询的时候经常涉及到多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则。
- **避免索引失效：**不要用左模糊匹配、函数计算、表达式计算等
- **查询优化：**避免使用select *，只查询真正需要的列，使用覆盖索引，及索引包含所有查询的字段，另外如果需要联表查询的话，最好要用小表驱动大表，并且被驱动的表最好要有索引。
- **分页优化：**针对limit n,y深分页的查询优化。
- **优化数据库表：**如果单表的数据超过了千万级别，考虑是否需要将大表拆成小表。
- **使用缓存技术：**引入Redis缓存层，数据和频繁查询的内容做缓存。