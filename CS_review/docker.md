# docker

## docker的cgroup和cnamespac的作用和原理

### cgroup——资源的限制和隔离

他主要是能够**限制、统计和隔离容器进程**能使用的**系统资源**。能限制的资源有CPU、内存、磁盘I\O、网络带宽、进程数等等（限制fork炸机器）。

```
docker run -m 512m --cpus=0.5 ubuntu
```

### namespace——环境隔离

主要是提供进程视角上的隔离，让容器里的进程觉得自己有独立的系统。

常见的namespace类型：

- `pid`：进程号隔离（容器里的进程pid从1开始）
- `net`：网络隔离（容器有独立网卡、IP、端口空间）
- `mnt`：挂载点隔离（容器有独立的文件系统视图）
- `uts`：主机名/域名隔离（容器有自己的hostname）
- `ipc`：信号量/共享内存
- `user`：用户隔离（容器里root可以映射到宿主机的普通用户）

## docker的容器的核心思想

核心思想之一就是镜像分层，镜像是由一层一层的文件系统叠加而成的。当我们运行一个容器时，docker不会复制整份镜像，而是在镜像的最上层挂在一个可写层，这样的话，镜像层就是只读的，容器写的东西只会写到最上层，这样多个容器就共享一份只读镜像层就可以了，节省存储空间。

## docker构建dockerfile的时候为什么倾向于把多条指令做合并呢？

每一条`RUN/COPY/ADD`指令都会生成一层镜像（layer）。镜像是分层存储的，层与层之间是只读的，只有最上面一层是容器运行时的可写层。这个时候合并指令有这个几个好处

1. **镜像更小：** 每一条都会保存 `/var/lib/apt/lists` 里下载的缓存文件，虽然你可能在后面清理掉了，但前面那层依然占空间。  
2. **构建速度更快：**镜像层数少->层之间的元数据少->拉取和推送更快
3. **避免缓存问题：**docker构建时会对每一层做缓存，合并后最后一条的缓存指令就可以把该层的缓存删干净，这样缓存命中更合理。

但是不要**“过度合并”**因为比较长的指令，如果某一句指令构建出错了，就需要重新执行，所以要适度。

## docker里面的overlayfs机制了解吗？

OverlayFS就是linux提供的一种联合挂在文件系统。他能把两个目录（**lowerdir**和**upperdir**）合并在一起，对外只显示一个目录。可能比如**lowerdir**作为只读层，比如镜像层，**upperdir**作为容器层，是可写层。然后他能够将这两个文件形成一个**merged**形成最终容器看到的文件系统。

他的运行机制就是：如果这个文件仅存在于`lowerdir`那么容器里能够读到他，如果文件被修改，OverlayFS会把`lowerdir`里的文件复制到`upperdir`这里使用的是写时复制机制。容器的修改只会作用在`upperdir`。

删除文件的时候，其实只是做一个”白条目“，在`upperdir`里标记该文件删除了。

## overlayFS在各个生命阶段都起什么作用呢?

在**镜像构建**阶段->分层存储+写时复制

**镜像分发**阶段->层复用+快速传输

**容器创建**阶段->lower+upper合并视图

**容器运行**阶段->写时复制+隔离

**容器快照**阶段->upperdir转化为新层

**容器删除**阶段->删除upperdir保留lowerdir

## dockerfile存在哪些指令？

```sql
┌───────────────┬───────────────────────────────────────────┐
│   类别        │                 命令说明                  │
├───────────────┼───────────────────────────────────────────┤
│ 基础镜像信息  │ FROM：指定基础镜像                        │
│               │ LABEL：设置元数据（推荐用这个代替MAINTAINER）│
│               │ MAINTAINER：维护者信息（已过时）           │
├───────────────┼───────────────────────────────────────────┤
│ 文件与目录    │ COPY：复制文件/目录到镜像                 │
│               │ ADD：类似COPY，支持URL和自动解压           │
│               │ WORKDIR：设置容器内的工作目录              │
├───────────────┼───────────────────────────────────────────┤
│ 构建与运行    │ RUN：构建镜像时执行命令                   │
│               │ CMD：容器启动时的默认命令（可被覆盖）       │
│               │ ENTRYPOINT：容器主命令（更固定）           │
├───────────────┼───────────────────────────────────────────┤
│ 环境与变量    │ ENV：设置环境变量                         │
│               │ ARG：构建阶段参数（docker build 传入）     │
├───────────────┼───────────────────────────────────────────┤
│ 用户与权限    │ USER：指定运行容器的用户                  │
├───────────────┼───────────────────────────────────────────┤
│ 网络与端口    │ EXPOSE：声明容器对外暴露的端口（文档用途） │
├───────────────┼───────────────────────────────────────────┤
│ 数据与存储    │ VOLUME：定义挂载点（数据持久化）           │
├───────────────┼───────────────────────────────────────────┤
│ 健康与触发    │ HEALTHCHECK：容器健康检查命令              │
│               │ ONBUILD：构建触发器，给基础镜像预定义动作  │
└───────────────┴───────────────────────────────────────────┘
```

## 常用概念

**镜像Image：**一个只读的模板，包含应用程序及其以来环境，类似虚拟机快照/ISO模板，通过OverlayFS实现

**容器Container：**镜像运行的一个是实例，这个一般都是upperdir，可读可写，可以运行、停止、删除重启

**仓库Repository：**存放镜像的地方Docker Hub

**Dockerfile：**构建镜像的脚本文件，定义镜像的构建步骤

**DockerEngine：**Docker 运行时的引擎，包括守护进程`dockerd`和CLI`docker`

**Volume：**用于持久化存储或者容器间共享数据

**Network：**容器通信的虚拟网络，支持`bridge、host、overlay`等多种模式

## docker内容和查看内存使用情况

在宿主机可以使用`docker stats`

```sql
docker stats

CONTAINER ID   NAME        CPU %     MEM USAGE / LIMIT     MEM %   NET I/O
a1b2c3d4e5f6   web_nginx   0.07%     128MiB / 2GiB         6.4%    1.2MB / 1.1MB
```

在容器内部可以使用`top`