# c++八股

### 构造函数能不能是`virtual`？

不能，c++明确规定构造函数不能声明为`virtual`。因为虚函数调用依赖vtable，而vtable指针是在构造函数里才被初始化的，在构造对象时，对象还没完全构造好，虚函数表也没有完全建立，所以没办法需通过虚函数表做动态绑定。

### 那析构函数能不能是`virtual`？

可以，而且有继承关系的时候必须写成`virtual`，如果通过基类指针删除子类对象，而基类析构函数不是虚函数，那么只会调用基类析构，而不会调用子类的析构，导致资源泄露，加上`virtual`，`delete basePtr`会先调用子类析构，再调用基类析构，保证资源释放干净。

###  class A里面有三个成员变量，初始化的顺序是怎么样的？  

- **成员变量初始化顺序 = 它们在类中被声明的顺序**。
- 即使你在构造函数初始化列表里写了不同的顺序，也不会改变实际的初始化顺序。
- **析构顺序刚好相反**，后声明的先析构。

### 指针针和引用的区别

**引用**

```c
int ival = 1024;
int &refVal = ival;
int &refVal2;    //  报错：引用必须初始化
```

引用并不是对象，它只是一个已经存在的对象所起的另外一个名字

**指针**

指针是指向另外一种类型的复合类型，区别：指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内他可以先后指向几个不同的对象；其二，指针无需再定义赋值，和其它内置类型一样，在快作用域内定义指针如果没有被初始化，也将拥有一个不确定的值。

**其实他俩在汇编层面都是使用指针实现的。**

### 函数传值的原则

| 判断问题                      | 推荐用法           |
| ----------------------------- | ------------------ |
| 参数必定存在且不能为 null     | `T&` 或 `const T&` |
| 参数可能为空或可选            | `T*`               |
| 函数需要修改传入值            | `T&` 或 `T*`       |
| 不希望修改传入值              | `const T&`         |
| 传递大对象以避免拷贝          | `const T&`         |
| 传递小型基本类型（int, char） | 按值传递           |
| 涉及资源管理或生命周期复杂    | 智能指针           |

**“能确定存在的，用引用；可能为空的，用指针。”**
**“不需要修改的，用 const 引用；需要修改的，用引用或指针。”**

### 如何防止野指针和悬空指针

**野指针**是指针指向了未初始化的内存或者无效的随机地址。

- 定义指针的时候立即进行初始化
- 避免使用未进行初始化的指针
- 使用智能指针

**悬空指针**是指针指向了已经释放掉的内存。

- delete后立即将指针置空
- 避免返回局部变量的地址，因为局部变量在离开作用域之后就结束被销毁了，返回他的地址会导致悬空指针
- 避免使用已经释放的内存。
- 多个指针指向同一个内存的时候要注意避免悬空指针。

### 什么情况下会出现野指针？

- 定义指针的时候没有做指针的初始化
- 指针指向的内容被释放了但没有被置空
- 数组的访问越界

### C++中左值和右值

- **左值**

- **左值表示一个具名的、持久存在的对象**，可以取地址（`&`）
- 通常出现在赋值表达式的**左侧**（也可以出现在右侧）

有明确的存储位置（内存地址），生命周期超出当前表达式、可以被多次使用。

- **右值**

- **右值表示一个临时的、即将销毁的值，**不能取地址
- 通常出现在赋值表达式**右侧**（但也可作为某些操作的参数）

没有持久的内存地址，生命周期仅限于表达式，只能被使用一次。

| **特性**         | **左值**                          | **右值**                   |
| ---------------- | --------------------------------- | -------------------------- |
| **持久性**       | 生命周期长，可重复使用            | 临时存在，用完即销毁       |
| **地址**         | 可获取地址（`&`）                 | 不可获取地址               |
| **典型示例**     | 变量、函数返回的左值引用          | 字面量、函数返回的临时对象 |
| **可绑定引用**   | 左值引用（`T&`）                  | 右值引用（`T&&`）          |
| **移动语义支持** | 需要显式转换为右值（`std::move`） | 天然支持移动语义           |

### 数据类型

####  整型 short int long 和 long long  

short类型最少16位

int类型最少与short一样长

long 类型最少32位，且至少与int一样长

longlong类型最少64位，且至少与long一样长

![img](G:\CPP\CS_review\assets\1741058462929-e5af94e0-39a2-4523-bc8a-54b666522510.png)

####  无符号类型 

 即为不存储负数值的整型，可以增⼤变能够存储的最⼤值，数据长度不变。 int 被设置为⾃然长度，即为计算机处理起来效率最高的长度，所以选择类型时⼀般选⽤ int 类型。  

### C++中的重载、重写和隐藏的区别

- 重载是指在同一个范围内定义两个函数名相同的函数，通过函数的参数和类型不同来区别函数，不能够仅仅通过函数的返回值实现重载。重载也是C++中多态的一个表现。
- 重写就是override，要是对基类函数的一个实现逻辑的重写，重写函数的函数体，要求基类必须是虚函数。

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的函数类型
- 与基类的虚函数有相同的返回值类型

- 隐藏是指不同类类中有继承关系时，比如父类有A函数，派生类有A函数，两个函数的传参类型、数量或者返回值不同，那么A对象的实例a，就会隐藏掉父类：：A函数。

### C++有哪些默认构造函数

- 默认构造函数：默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
- 初始化构造函数（有参数）
- 拷贝构造函数：复制构造函数用于复制本类的对象
- 移动构造函数（move和右值引用）
- 转换构造函数：转换构造函数用于将其他类型的变量，隐式转换为本类对象

### C++中的浅拷贝与深拷贝区别

浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一个地址，如果原来的指针所指向的资源释放，那么在释放浅拷贝的指针的资源会出现错误。

而深拷贝不仅能拷贝值，还需要开辟一块新的内存空间来存放新的值，即使原来的对象被析构了，释放内存也不会影响到深拷贝的值。

### 内联函数和宏定义的区别

- 宏只做简单字符串替换（在预处理阶段），而内联函数会在编译时进行参数类型检查，并且有返回值。
- 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高效率，并进行参数类型检查。 内联函数支持重载、有返回值、有作用域  。

### C++的函数调用的压栈过程

函数的调用过程：

从栈空间分配存储空间，从实参的存储空间复制值到形参的栈空间，然后进行运算，形参在函数没有调用之前都是没有分配内存空间的，在函数调用结束后，清楚形参的空间。当传输入的参数是一个指针的时候，形参和实参改变同一块内存空间，从而可以发生改变，函数调用结束后，形参的指针释放掉了。

指针参数本质上是值传递（地址的拷贝）；
要修改指针指向的地址，需要“指针的引用”；
引用传参是对变量本身操作，更直接、类型安全、不可更换绑定对象。  

### 关于函数返回值的问题

函数执行完之后栈是会被释放的，所以说在栈内的局部变量，要是使用`return temp`返回的话，return的逻辑就是将temp的值通过寄存器存储下来，但是原来temp的地址（也就是在栈中的地址）已经被释放或者被复用了，所以说返回值是没有问题的，但是不要返回地址，会出错。而返回值的过程就是利用寄存器保存的值然后赋值给你主函数中接收该值的变量。

### 静态绑定和动态绑定

静态绑定发生在编译期，比如对象A作为基类，对象B作为子类，`A* pa = new B();`这个时候pa的静态绑定就是A*，而动态绑定发生在运行期，动态绑定在此例终究是B*；对象的动态绑定类型可以更改，但是静态绑定类型不能够更改。想要实现多态的话，必须使用动态绑定。在继承体系中，只有虚函数采用的是动态绑定，其他成员函数等都是适用的静态绑定。

 **“静态类型”**决定了编译器能看见的接口；
**“动态类型”**决定了程序运行时真正用到哪个类的实现；
**“静态绑定”**在编译时就确定了调用哪个函数；
**“动态绑定”**需要运行时查找虚函数表。  

#### 引用的动态绑定

引用是可以动态绑定的，但是这个范围仅限于虚函数，比如一个子类B中的`virtual func1()   func2()`如果你定义`A &a = b`;那么a倒是可以调用子类的`func1()`，但是不可以调用`func2()`；

### 为什么模板都写在`.h`文件里？

- **C++ 编译是一个** `**.cpp**` **一个** `**.cpp**` **编译的（分离编译）**；
- 如果你把模板定义写在 `a.cpp` 文件里：
- 那么除非 **在** `**a.cpp**` **文件里就用到了这个模板**，否则它**根本不会被编译器实例化**；
- 而你在另一个 `main.cpp` 文件里去用它时，只 `#include` 了 `add.h` 的声明（不是定义），编译器 **无法在这里实例化模板代码**，也就没有函数体了；
- 最终，链接器也找不到函数体，报错。

### 关于重载的匹配流程

C++ 编译器在处理函数重载时，会先收集所有同名函数作为候选集，然后根据参数个数和类型过滤出可以调用的函数（可行集），最后再根据精确匹配度、类型转换成本等规则，选出最佳匹配。

精确匹配优先，其次是标准类型提升，再到用户自定义转换，如果两个函数都一样接近就会产生二义性错误。

所以写重载函数时要尽量避免模糊转换，例如 float 同时能转成 int 和 double 的情况。

### C++的标准库都有哪些？

| 类型         | 模块名称                              | 典型例子                                  |
| ------------ | ------------------------------------- | ----------------------------------------- |
| C 函数库     | `stdio.h`, `math.h`, `stdlib.h`       | `printf`, `sqrt`, `malloc`                |
| C++ 类库     | `iostream`, `string`, `vector`, `map` | `std::cout`, `std::string`, `std::vector` |
| STL 组件     | 容器、算法、迭代器、函数对象、分配器  | `std::sort`, `std::map`, `std::less`      |
| 本地化与异常 | `locale`, `stdexcept`, `exception`    | `std::runtime_error`, `std::locale`       |

主要还是分两个部分一个部分是继承自C语言的库，也就是比如`cmath、ctime、cstring、cstdlib`等等，分别是提供一些数学计算的库函数、时间库函数、字符串库函数以及`cstdlib`中的`malloc、free`等。

然后另一部分跟就是Cpp的库函数`iostream、string、vector、map、alogrithm、iterator、stdexcept`等，分别是提供面向对象IO、c++字符串、动态数组容器、常用算法（`sort、find、reverse`）以及容器遍历的迭代器和异常处理的库。

### cout后面为什么一定要加endl

其实加不加都可以不会报错，但是因为不加endl可能会因为输入的内容在缓冲区里面，如果缓冲区没有满，可能会不及时输出，`/n`只是做换行，但是不会立即刷新缓冲区，而通过`endl`不仅可以换行，还可以立即刷新缓冲区。如果是在运行过程中输出一些调试信息，最好是加上endl，这样能够保证及时输出。

### 文件编译的过程是怎么样的

文件编译的过程经历这么几步由`.cpp->.i->.s->.o`第一部预处理就是先把那些宏定义、条件编译、注释、以及头文件都展开，这样就得到干净的代码，然后进入编译阶段，编译的时候就是对`.i`文件的内容进行语法、词发的分析，会进行类型检查和语义分析，然后进行一些编译的寄存器优化类似的，然后生成汇编语言`.s`这个时候在交由汇编阶段做处理，汇编阶段其实就是对照着机器码以及汇编指令进行翻译，最后进入链接阶段进行多个模块的链接。

### 动态库做什么事情？

动态库的核心作用就是**把可执行文件需要的代码和数据,延迟到运行时再加载和绑定。**

一个动态库在内存中只需要加载一次，不同的进程能够共享这段代码。

在链接阶段，可执行文件只保留函数/变量的符号引用，不打包真实的实现，程序运行的时候，动态链接器负责装在动态库到进程地址空间，查找符号地址，把调用位置修正为真正的函数地址。

 动态库可以在运行时按需加载（`dlopen`/`dlsym`）。  

### `main`文件的执行顺序是怎么样的？

第一个阶段由操作系统完成程序加载，主要是完成：

- 设置栈指针
- 初始化`.data`段（复制初值到内存）
- 清零`.bss`段（未初始化全局变量）
- 调用全局对象构造函数
- 执行带`__attribute__((constructor))`的函数

然后进入`main()`函数执行主体逻辑注册`atexit()`回调

当`main()`函数返回：

- 调用atexit注册的函数
- 调用全局对象的析构函数
- 执行带`__attribute((destructor))`

### 函数`return 0`是什么意思

返回0是返回给操作系统的，表示程序执行成功退出。

编译器在 `main()` 返回时自动调用 `exit(status)`；

`exit(status)` 会：

- 调用所有注册的 `atexit()` 回调；
- 执行全局对象的析构函数；
- 刷新缓冲区（如 `cout`、`stdout`）；
- 通知操作系统：**进程结束**，并返回 `status` 作为退出码。

如果 `main()` 执行完毕没有显式返回值，编译器会自动加上 `return 0;`。  

### 最终运行的可执行文件ELF的结构是什么样的？

Liunx平台下，可执行文件通常是ELF（Executable and Linkable Format）格式

- **ELF header**

- 文件的类型
- 机器的架构
- 程序的入口地址
- 程序头表和节区头表的位置

**可以理解为就像目录的索引，告诉操作系统如何解析文件**

- **程序头表**

- **进程装载时需要映射的段**

- **.text**：代码段（机器指令，可执行，只读）
- **.data：**已初始化的全局/静态变量（可读写）
- **.bss：**未初始化的全局/静态变量（运行时清零）
- **.rodata：**只读数据（常量字符串、const 变量）

### TLS线程局部存储

当你调用 `pthread_create()` 时：

glibc 会：

1. 分配线程栈；
2. 分配线程控制块（TCB）；
3. 拷贝 `.tdata` / `.tbss` 段到新线程的 TLS 区域；
4. 设置 FS 寄存器指向该 TLS 区域。

###  闭包（Closure）类型是什么？它和普通类型有什么区别？  

**闭包**是一个**函数对象**，它不仅能够像调用函数一样,还携带着创建时捕获的环境变量。

就比如说Lamuda比倒是定义是可以捕获外部作用域的变量，编译器会生成一个匿名结构体类（这个也就是闭包类型）来保存这些捕获的变量。

**lambda 表达式 ≈ 编译器自动生成的一个结构体类对象。**  

## 关键字

### const关键字

如果我们希望某个值不想被改变，可以用const来修饰，使其变成常量

#### const的引用

```c
const int ci = 1024;
const int &r1 = ci;         //正确：引用及其对象都是常量
r1 = 42;                    //错误：r1是对常量的引用
int &r2 = ci;               //错误：ci是常量，不能是同通过一个非常量引用指向一个常量对象
```

#### 值传递、指针传递、引用传递的区别和效率

- 值传递：存在一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是大的对象或者结构体，需要进行拷贝，耗费时间和空间。
- 指针传递：同样存在一个形参向函数所属的栈拷贝数据的过程，但是拷贝的是指针，固定是4个字节的地址。
- 引用传递：同样有上述的数据拷贝过程，但是是针对地址的，相当于为数据所在的地址起了一个别名。
- 指针传递和引用传递效率更高。

#### const关键字的作用

- 阻止一个变量被改变，可以使用const关键字。在定义该变量时，通常需要对他进行初始化。
- 对指针来说，const即可以修饰指针，作为顶层const是一个常量指针。也可以修饰指针指向的值，作为底层const是一个指针常量。
- 在一个函数中，const可以修饰形参，表明它是一个输入参数，不可以对他进行改变。
- 在类中const成员函数可以访问非const对象的非const数据成员、const数据成员也可以访问const对象内的所有数据成员。（表达只读的意图）

### static关键字

- 隐藏：同时编译多个文件时，所有未加`static`前缀的全局变量和函数都具有全局可见性
- 保持变量内容的持久。存储在静态数据区的变量会在程序开始运行时就完成初始化，也是唯一一次的初始化。

- 静态数据区存储全局变量和静态变量，默认初始化为零

- 在类内声明`static`变量

- 在类内的`static`成员变量属于整个类拥有，对类的对象只有一份拷贝
- 在类中的`static`成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的`static`成员变量。
- static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化;

#### static成员和普通成员的区别

- 生命周期：

- 静态成员的变量从类被加载到类被卸载，一直都存在。
- 但是普通成员的话对象开始的时候才存在，然后对象结束就终止了。

- 共享方式

- 普通成员变量是每个对象单独享用的。
- 静态成员变量是全类共享

- 定义位置

- 普通成员变量存储在栈区或者堆区
- 而静态成员变量存储在静态全局区

- 初始化位置

- 普通成员变量在类中初始化
- 静态成员变量在类外初始化

#### static的懒初始化

在C++中可能存在某个`static`成员函数中，存在`static`的对象，而对象的构造需要调用构造函数，所以并不是简单的进行内存分配就行了，因此在C++中，只有在第一次执行到定义位置时，才进行`static`成员的构造。从而提高效率，减少不必要的构造。

### new和malloc的区别

1、 `new/delete`是C++关键字，需要编译器支持。`malloc/free`是库函数，需要头文件支持;

2、 使用`new`操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而`malloc`则需要显式地指出所需内存的尺寸。

3、`new`操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故`new`是符合类型安全性的操作符。而`maloc`内存分配成功则是返口`void*`，需要通过强制类型转换将`void*`指针转换成我们需要的类型。

4、 `new`内存分配失败时，会抛出`bac_alloc`异常。`malloc`分配内存失败时返回`NULL`。

5、`new`会先调用`operatornew`函数，申请足够的内存通常底层使用`maloc`实现)。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。`delete`先调用析构函数，然后调用`operator delete`函数释放内存(通常底层使用`free`实现)。`maloc/free`是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

#### new和delete底层行为：

比如如果要`new`一个复杂类型的对象，而且不止`new`一个，可能会用到

```
MyClass* arr = new MyClass[3];
delete[] arr;
```

在第一条语句中，`new`的过程需要先调用`operator new[](sizeof(MyClass) * 3 + 4)`，前四个字节保存元素的个数，后面保存分配的对象的地址。返回的是，指向对象的第一个地址空间的地址。

在第二条语句中，需要先取出真实地址，也就是记录元素个数的地址，第一个元素地址-4，取出元素个数，然后再调用元素个数次析构函数把内存释放。

#### malloc

底层采用的是brk和malloc系统调用进行内存分配，当分配的内存空间小于128k的时候，默认使用brk进行内存分配，这个空间主要分配在堆上，是一个连续的内存地址，释放必须要等到堆上面的地址内存释放掉后才能进行释放，而当申请的内存空间较大的时候，采用的是mmap，这个空间是在匿名文件映射区实现的内存分配，这个内存是不连续的，更容易进行内存回收，避免内存碎片。

### 关于内存泄漏

内存泄漏主要是指的堆内存的泄漏，堆内存是由程序从堆中分配的，大小任意的内存块，运行完成之后必须要显示的释放内存，应用程序一般使用malloc以及new等函数从其中分配内存，如果这块内存不使用了有没有被释放，就会产生内存泄漏

避免方法：

- 参考智能指针，每次new的时候，计数都+1，delete的时候计数都-1，保证new和delete成对出现。
- 一定要将基类的析构函数声明为**虚函数**。 只要函数是虚函数（virtual），基类指针/引用就可以通过虚函数表（vtable）调用子类的实现。  
- 对象数组的释放一定要用`delete[]`

### 类型转换

- `static_cast`

- **基本类型转换：**如`int`转`double`，`enum`转`int`
- **父子类指针/引用转换：**将基类指针转换成派生类指针（向下转换，**不检查安全性**）
- **隐式转换的显示化：**例如将void*转换成int*
- **无关类型转换：**需要用户自定义转换运算符

在编译期完成，无运行时的开销，不检查安全性，如果转换逻辑错误（无效的向下转换），可能导致未定义行为，不可移除`const`

- `dynamic_cast`

- **多态类型的向下转换：**将基类指针/引用安全的转换为派生类指针/引用。
- **运行时类型检查：**检查转换是否合法，失败则返回`nullptr`或抛出异常

依赖多态，也就是说基类必须有虚函数；运行时存在开销，运行时需要进行安全类型检查；出错时会返回`nullptr`；

```cpp
Base* base = new Derived();          // 基类指针实际指向 Derived 对象
Derived* derived = dynamic_cast<Derived*>(base); // 成功
Base* invalid_base = new Base();      // 基类指针指向 Base 对象
Derived* invalid_derived = dynamic_cast<Derived*>(invalid_base); // 失败
```

- `const_cast`

- **移除或添加**`**const/volatile**`**属性：**修改第三方库中标记为`const`的变量
- **无类型转换：**进修改属性，不改变底层数据布局

若修改原本为`const`的对象，可能导致未定义行为，不能用于无关类型的转换，如`int*`转换成`double*`。

- `reinterpret_cast`

- 低级别的指针类型转换：如`int*`转换`char*`
- 整数与指针互转：例如将指针地址保存为整数
- 无关类型的强制转换：如`struct`转`int`

最不安全的转换，不检查类型逻辑，完全依赖开发者。转换结果可能因编译器或者平台而异。慎用于跨平台代码开发。

### std::lock_guard

- **自动加锁与解锁：**在构造函数中自动调用`mutex.lock()`加锁，在析构函数中自动调用`mutex.unlock()`解锁。这种设计确保即使发生异常或提前返回，锁也能被正常释放，避免死锁。
- **作用域绑定：**所的生命周期严格绑定到`lock_gurad`对象的作用域。当对象离开作用域（如函数返回或代码块结束）时，析构函数触发解锁。

### override关键字

核心作用是显示的声明当前函数的意图是重写基类的虚函数，如果函数签名与基类虚函数的签名不同（比如拼写错误、或者参数传递错误），编译器会直接报错，避免运行才发现未正确重写。无论是否使用`override`，虚函数的重写行为都是在**运行时才实现多态（通过虚函数表绑定）**，`override`的作用是在编译时静态检查。

### constexpr和const的区别

### std::forward

1. 完美转发的核心作用

- 保持参数的原始值类别（左值/右值属性），避免在传递过程中被强制转为左值
- 解决函数模板中参数传递时的属性丢失问题

1. 必须配合 `&&`（通用引用）使用

- 只有模板参数中的 `T&&` 才是通用引用（可绑定左值/右值）
- 非模板的 `&&` 只是普通的右值引用

### volatile关键字

- 告诉编译器：`flag` 这个变量的值可能 **被外部改变（比如其他线程、硬件中断、IO寄存器等）**。
- 因此：

- **每次使用** `**flag**` **的时候都必须从内存中重新读取值**
- **不能将** `**flag**` **缓存在寄存器中**

- 能解决 **内存访问可见性问题**
- 不能解决 **原子性（多个操作的不可中断性）**
- 不能代替 **互斥锁 / 原子操作**

### 强制类型转化关键字：`reinterpret_cast/const_cast/static_cast /dynamic_cast`

`static_cast<T>(expr)` 主要是用在常规类型转换以及父子类型转化，编译期进行转换，会进行类型安全检查。运行时无检查，**容易将父类指针错转成子类指针**。

`dynamic_cast<T>(expr)`用于多态（有虚函数）的安全指针转换（运行时检查），基本都是有基类指针/引用->子类指针/引用（向下转化），要求必须要有虚函数。

`const_cast<T>(expr)`主要是用于去除`const`限定符

`reinterpret_cast<T>(expr)`进行底层的位级别转换，比较危险，一般用在指针转整形，整形转指针，不想管类型指针间的强制转换。

### `define、const、typedef、inline`的作用？

`define PI 3.14`就是在预处理阶段只做文本的简单替换，是没有内存地址的，也不做类型安全检查。

而`const double PI = 3.14`发生在编译阶段，有类型，有真正存储的内存地址，也会做安全检查。

`define uint unsigned int`就是做简单文本替换，不会报错，也不会检查，用错也不会提示，

`typedef unsigned int uint`是告诉编译器，`uint`就是`unsigned int`能够参与类型检查。

`inline`能够进行调式，保留调式信息，并且能在小函数时性能可以优化。

### `atomic`

 在多核下普通变量可能只改在本核缓存/写缓冲里，其他核还能看到旧值；

而 `std::atomic` 的写会生成带 `LOCK` 前缀的原子指令（如 `LOCK XCHG/CMPXCHG`），把目标**缓存行**拿到全局独占，按 MESI 协议把其它 CPU 的同一缓存行**置为 Invalid**，这样其它核再读时要么从内存、要么直接从我这核拿到**最新数据**，因此具备**可见性**；同时原子操作会按照指定的内存序插入**fence**（屏障）来约束**指令重排**，保证**有序性**。

需要强调的是：这并不等于立刻刷回 DRAM，真正保证的是通过缓存一致性协议让其他核**读不到旧值**并遵守顺序语义，这也是 `atomic` 比 `volatile` 更适合并发的根本原因。  

#### 关于`atomic`所带的库函数

| 函数           | 含义         | 示例                |
| -------------- | ------------ | ------------------- |
| `load()`       | 原子地读取值 | `int x = a.load();` |
| `store(value)` | 原子地写入值 | `a.store(5);`       |
| `operator=`    | 原子赋值     | `a = 5;`            |
| `operator T()` | 原子读取值   | `int x = a;`        |

| 函数             | 描述         | 等价       |
| ---------------- | ------------ | ---------- |
| `fetch_add(val)` | 原子加       | `a += val` |
| `fetch_sub(val)` | 原子减       | `a -= val` |
| `fetch_or(val)`  | 原子按位或   | ``a`       |
| `fetch_and(val)` | 原子按位与   | `a &= val` |
| `fetch_xor(val)` | 原子按位异或 | `a ^= val` |

 ⚠️：所有 `fetch_xxx(val)` 返回的是**原始值**，不是修改后的。  

```cpp
bool compare_exchange_weak(T& expected, T desired);
bool compare_exchange_strong(T& expected, T desired);
```

- 如果 `a == expected`，就更新为 `desired`，返回 true
- 否则，`expected` 被修改为当前的 `a`，返回 false

#### 无锁编程内存序

有几种常用的内存序`memory_order_relaxed`、`memory_order_realse`、`memory_order_acquire`，第一种内存序指令可以重排，也就是说在线程1执行了`store(1)`的内容可能还没有加载到主存，所以线程2使用`load()`的时候可能读不到这个值，如果你使用了`store(1,memory_order_realse)`就需要等待释放，这个过程就是真正的将1以及加载到主存了，而线程2的`load(memory_order_acquire)`必须排序到`realse`之后，所以能够保证一定能读到1。

### 仿函数和lambda表达式

仿函数就是重载`operator()`的一个类，这个类重载了`operator()`运算符，并且在其中实现了自己的操作逻辑，比如对象的加减等操作。它的对象可以向调用函数一样来调用，就是Functor = Function+object，他还有自己的这个成员变量，这个成员变量可以做引用计数啊之类的，能够通过成员变量进行状态的携带，还能够被编译器进行内联优化，已经灵活传递算法。

然后lambda表达式就是一种匿名的仿函数。在编译后会生成一个匿名类，这个类型被称为闭包类型。这个类会重载`operator()`并且还会保存捕获的变量有 `[=]` / `[&]` / `[x]` 捕获  。

```cpp
struct __lambda_12345 {
    int operator()(int a, int b) const {
        return a + b;
    }
} add; // add 是这个匿名类的实例
```

它可以给STL传递作为底层的比较器，但是如果使用`lambda`表达式的话，就必须要用decltype关键字来获取这个表达式的类型，并且通过`std::map<int,int,Cmp> mp(Cmp);`表达式来实现。

然后这个内容其实在协程库的时间堆里面有用到过

```cpp
// 实现最小堆的比较函数
struct Comparator 
{
    bool operator()(const std::shared_ptr<Timer>& lhs, const std::shared_ptr<Timer>& rhs) const;
};
bool Timer::Comparator::operator()(const std::shared_ptr<Timer>& lhs, const std::shared_ptr<Timer>& rhs) const
{
    assert(lhs!=nullptr&&rhs!=nullptr);
    return lhs->m_next < rhs->m_next;
}
```

## C++-STL容器

### vector容器

- **容量管理**

```cpp
v.size();
v.capacity();
v.empty();
v.resize();
v.reserve(n);
v.shrik_to_fit();
```

- `size()`返回实际元素数量，`capacity()`返回当前分配的容量。
- **可以通过**`**reserve(n)**`**预分配内存，避免频繁扩容；**`**shrink_to_fit()**`**可请求释放多余内存。**

- **元素访问**

```cpp
v[i];		  // 随机访问第 i 个元素（无边界检查）
v.at(i);      // 带边界检查，越界抛出 std::out_of_range
v.front();
v.back();
```

- 支持通过下标（`operator[]`）或者`at()`直接访问元素，时间复杂度为`O(1)`。
- `at()`会进行边界检查，越界时抛出`std::out_of_range`异常，而`operator[]`可能导致未定义行为。

- **元素修改**

```cpp
v.push_back(x);
v.pop();
v.insert(pos,x);
v.erase();
v.clear();
v.emplace_back();
```

- 底层基于连续内存块实现，可以自动扩展容量
- 扩容时需重新分配内存并拷贝元素，时间复杂度为`O(n)`,但均摊后的尾部插入操作仍为`O(1)`。

- **迭代器支持**

- 提供随机访问迭代器（`begin()，end()，rbegin()，rend()`等）兼容STL算法比如`sort，find`

#### `push_back()`和`emplace_back()`的区别

`push_back(b)`是在栈空间先构造一个对象b,会调用对象的初始化构造函数，然后在调用对象的拷贝构造函数，将这个对象拷贝到堆区，而`emplace_back()`就是直接在堆区构造一个对象，没有调用拷贝构造函数的过程。比较高效。

### List容器

- **容量管理**

```cpp
l1.empty();
l1.size();
l1.max_size();
```

`list`**没有** `**capacity()**` **或** `**reserve()**`，因为它不是连续内存。

- **元素访问**

```cpp
l1.front();
l1.back();
```

不支持 `operator[]` 或 `at()`：链表不具备随机访问能力，访问第 n 个元素需要遍历。

- **元素修改**

```cpp
l1.push_back(val);
l1.push_front(val);
l1.pop_back();
l1.pop_front();

l1.insert(pos,val);
l1.erase(pos);

l1.clear();
```

- 所有插入、删除操作都不会导致其他元素移动
- 操作效率 O(1)，因为只需改指针

### deque容器

`std:deque`是一个支持**常数时间头尾插入和删除**的**可随机访问序列容器**

✅ **支持随机访问（像 vector 一样）**

✅ **支持两端插入/删除（像 list 一样）**

❌ **不适合中间插入（因为内存非连续）**

**底层结构：**

`**deque**` **不是一块连续内存，而是由一组****连续的小块内存块（chunk）组成的分段数组****：**

```plain
[map] → 指针数组，指向一块块 buffer

   map → [chunk1] [chunk2] [chunk3] ... [chunkN]
              ↓        ↓         ↓
           [elem]   [elem]    [elem]
```

- **容量管理**

```cpp
d.size();
d.empty();
d.max_size();
```

 没有 `capacity()`，因为 deque 的内存是分段分配的，无法像 vector 那样统计连续容量  

- **元素访问**

```cpp
d[i];
d.at(i);
d.front();
d.back();
```

支持 O(1) 的随机访问，实现方式：计算 `i` 所在的 chunk 和在 chunk 中的偏移

- **元素修改**

```cpp
d.push_front();
d.push_back();
d.pop_back();
d.pop_front();

d.insert(pos,val);
d.erase(pos);
d.clear();
```

### queue

`std::queue` 是一个**先进先出**（FIFO）**队列容器适配器**。

它不直接管理数据，而是基于其他容器（默认是 `deque`）来实现队列的行为。

```cpp
//容量相关
q.size();
q.empty();
//元素访问
q.front();
q.back();
//元素修改
q.push(val);
q.pop();
```

| 操作      | 时间复杂度 | 说明                 |
| --------- | ---------- | -------------------- |
| `push()`  | O(1)       | 调用底层 `push_back` |
| `pop()`   | O(1)       | 调用底层 `pop_front` |
| `front()` | O(1)       | 获取第一个元素       |
| `back()`  | O(1)       | 获取最后一个元素     |

### priority_queue(堆)

`std::priority_queue` 是一种**容器适配器**，提供了常数时间内访问最大（或最小）元素的能力。

它内部使用 **堆（heap）** 实现，默认是**大顶堆**（最大优先队列）。

**底层原理**

底层使用`std::vector`+堆算法

```cpp
//插入过程使用(自动上浮)
vec.push_back(x);
std::push_heap(vec.begin(),vec.end(),comp);

//删除堆顶元素过程（自动下沉）
std::pop_heap(vec.begin(),vec.end(),comp);
vec.pop_back();
```

如何使用

```cpp
auto cmp = [](const Node& a,const Node& b){
    return a.val>b.val;
}//小顶堆

std::priority_queue<Node,std::vector<Node>,deltype(cmp)> pq(cmp);

//pq本身只有几个个常用的接口函数
pq.pop();       //O(logn)
pq.push();		//O(logn)
pq.top()		//O(1)
pq.size()
pq.empty();
```

### stack容器

`std::stack`是一个后进先出的容器适配器，封装了底层容器，仅提供栈的基本操作接口。

底层容器默认是`deque`，也可以是`vector`、`list`，但不能使用`std::map、std::set`这种不支持尾部插入删除的结构

```cpp
std::stack<int> s1;
std::stack<int,vector<int>> s2;  //改用vector做底层容器
```

- **容量函数**

```cpp
s1.size();
s1.empty();
```

- **元素访问**

```cpp
s1.top();    //O(1)
```

- **元素修改**

```cpp
s1.push(x);		//O(1)
s1.pop();		//O(1)
```

底层使用`deque`支持头尾操作，都很高效，`vector`尾部插入和删除高效，`list`插入删除灵活但是访问慢。

### `std::set/std::map`容器

底层实现是由红黑树实现的。红黑树的插入删除时间复杂度都是`O(logn)`由于红黑树的本身特性使其保持近似的平衡，这样的话再插入效率上实际上要比平衡二叉树要好一些，但是再查找上不如平衡二叉树。

```cpp
//set 是不可重复的存的都是value
set<int> s1;
s1.empty();
s1.size();
s1.clear();

s1.insert(x);
s1.find(x);   //返回iteartor
s1.count(x);
s1.lower_bound(x);
s1.upper_bound(x);
```

`map`是存储键值对的容器

```cpp
map<pair<int,int>> m1;
m1[key1] = value1;
m1.insert({key1,value1});
m1.erase(key1);
m1.find(key1);
m1.count(key1);

m1.empty();
m1.clear();
m1.size();
```

### 为什么成员初始化列表效率更高？

本质也是因为，成员初始化列表会调用带参构造函数直接构建一个对象，而如果是赋值（`a = A(10)`）会多调用默认构造函数和拷贝赋值构造函数。

### std::allocator

`std::allocator`是C++标准库提供的默认内存分配器，用于管理动态内存分配和释放。它是所有标准容器（比如`std::vector`、`std::list`）的默认内存分配器，但也可以自定义。

- **基本作用**

- **内存管理：**分离对象的构造（`construct`）和内存分配（`allocate`），避免`new/delete`的直接使用。
- **泛型支持：**适用于任意类型`T`，提供类型安全的内存操作。
- **标准容器依赖：**`std::vector<T>`等容器默认使用`std::allocator`。
- `std::allocator` 是 C++ 标准库提供的默认内存分配器，用于管理动态内存的分配和释放。它是所有标准容器（如 `std::vector`、`std::list`）的默认内存分配器，但也可以自定义。以下是其核心特性和用法：

- **核心成员函数**

| 函数                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| `allocate(n)`        | 分配 `n` 个 `T` 类型对象的未初始化内存。                     |
| `deallocate(p, n)`   | 释放从 `p` 开始的 `n` 个 `T` 类型对象的内存（不调用析构函数）。 |
| `construct(p, args)` | 在地址 `p` 上构造一个 `T` 类型对象（使用参数 `args`）。      |
| `destroy(p)`         | 销毁 `p` 处的对象（调用析构函数，但不释放内存）。            |

**注**：C++17 后，`construct()` 和 `destroy()` 被弃用，建议直接使用 `std::construct_at` 和 `std::destroy_at`。

- **示例1：基本内存分配**

```cpp
#include <memory>

int main() {
    std::allocator<int> alloc;

    // 分配 5 个 int 的内存
    int* p = alloc.allocate(5);

    // 构造对象
    for (int i = 0; i < 5; ++i) {
        alloc.construct(p + i, i * 10); // p[i] = i * 10
    }

    // 使用内存
    for (int i = 0; i < 5; ++i) {
        std::cout << p[i] << " "; // 输出: 0 10 20 30 40
    }

    // 销毁对象并释放内存
    for (int i = 0; i < 5; ++i) {
        alloc.destroy(p + i);
    }
    alloc.deallocate(p, 5);
}
std::vector<int, std::allocator<int>> v; // 等同于 std::vector<int>
v.push_back(42); // 自动调用 allocator 分配内存
```

- **特点与注意事项**

- **无状态**：默认 `std::allocator` 无成员变量，所有实例行为相同。
- **性能**：通常直接封装 `::operator new/delete`，无特殊优化。
- **与** `new` **的区别**：

- `new T`：分配内存 + 构造对象。
- `allocator.allocate()`：仅分配内存，需手动构造。

### map以及unordered_map的使用场景

`std::map`适用于需要进行排序的场景，尤其是当需要对间进行遍历并按顺序处理时。因为它提供了有序的遍历。例如需要从小到大输出所有键值对，或者进行区间查询的时候，使用map方便，我也使用过`std::set`做时间轮。**排序操作、区间查找、需要保持数据顺序。**

`std::unordered_map`适用于不需要顺序、但对查找效率要求高的场景，特别当需要进行频繁插入和删除时，`unordered_map`通常更高效。  **高频查找、计数、存储无序数据时。**

## C++11新特性

### `std::move`关键字

它不是及移动任何数据，而是一种类型转换工具：他将对象的类型强制转化成右值引用（&&），表示该对象是“临时”或“可被移动”的。

```cpp
#include <utility>  // 需要包含此头文件
T obj;
T&& moved_obj = std::move(obj);  // 将 obj 转为右值引用
```

- **这样做的好处**

- **避免不必要的深拷贝：**对于管理资源的对象（如std::vector、std::string、自定义类）直接拷贝可能涉及大量内存操作，而移动语义允许直接“窃取”资源（如指针），效率更高。

```
// 深拷贝（低效） std::vector<int> v1 = {1, 2, 3}; std::vector<int> v2 = v1;  // 复制所有元素 // 移动语义（高效） std::vector<int> v3 = std::move(v1);  // v1 的资源转移给 v3，v1 变为空
```

### 移动构造函数

右值引用的核心目的是实现资源的高校转移，避免深拷贝。

```cpp
class MyString {
public:
    // 移动构造函数（参数为右值引用）
    MyString(MyString&& other) noexcept {
        data_ = other.data_;   // 直接“窃取”资源
        size_ = other.size_;
        other.data_ = nullptr; // 原对象置空
    }

private:
    char* data_;
    size_t size_;
};

MyString s1 = "Hello";
MyString s2 = std::move(s1);  // 调用移动构造函数，s1 的资源被转移给 s2
```

移动构造函数和拷贝构造函数的不同就在于，移动构造函数的参数是一个右值，而拷贝构造函数的参数是一个左值，move的就是能够以将一个左值转换成右值，这样的话，当调用了移动构造函数之后，原来的参数因为是右值，就会被销毁了，而拷贝构造函数的参数还存在着，因为是左值。

### std::enbale_shared_from_this

当一个对象被`shared_ptr`所管理时，如果需要再给对象内部获取指向自身的`shared_ptr`，直接通过`this`创建新的`shared_ptr`会导致多个独立的控制块，会产生两个问题：一个是重复析构，两个独立的`shared_ptr`会各自维护引用计数，当值对象被多次释放。另一个问题，悬垂指针，当其中一个`shared_ptr`释放对象后，另一个`shared_ptr`仍持有无效地址。当对象需要在异步操作（如网络I/O、定时器、线程池任务）的回调中延长自身生命周期时，需将自身的 `shared_ptr` 绑定到回调中。当对象需要将自身传递给其他模块（如事件处理器、观察者模式），并要求对方持有共享所有权时。`enbale_shared_from_this`内部维护一个`weak_ptr`（也叫`weak_this`）用于跟踪对象的控制块。当通过`std:shared_ptr<T>(new T)`或者`make_shared<T>()`创建对象时，若T继承自`enable_shared_from_this`，`shared_ptr`的构造函数将会调用T内部的`internal_accept_owner`方法，将自身的控制块绑定到`weak_this`。当调用`shared_from_this()`时，内部尝试将`weak_this`提升为`shared_ptr`。如果提升成功，也就是说该指针指向的对象至少被一个`shared_ptr`持有，就返回合法的`shared_ptr`。否则抛出`bad_weak_ptr`异常。

### `std::result_of`

`std::result_of` 是 C++11 引入的一个**类型萃取（type trait）工具**，用于在编译期确定调用某个可调用对象（函数、函数指针、成员函数、函数对象、lambda 表达式等）时的返回类型。

```cpp
int func(double);
using Type = std::result_of<decltype(func)(double)>::type;
// Type 是 int
auto lambda = [](int x) -> std::string { return std::to_string(x); };
using Type = std::result_of<decltype(lambda)(int)>::type;
// Type 是 std::string
```

### `std::future`

`std::future` 提供了一种访问异步操作结果的机制：

- **异步操作：**在另一个线程执行的计算
- **未来值：**现在还不存在，但将来会有的结果
- **结果获取：**通过 `future`对象获取异步操作的结果

### 可变参数模板

可变参数模板是C++引入的一种模板机制，可以让模板接受任意数量的参数，它的核心就是模板参数包。

```cpp
template<typename... Args>
void print(Args... args) {
    (std::cout << ... << args) << std::endl;
}//这个是c++17中的折叠表达式实现的。
//C++11中可以使用递归展开。
template <typename T>
void print(T arg) {
    std::cout << arg << " ";
}

template <typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // 递归调用
}
```

### 智能指针

#### `shared_ptr`

它是一种智能指针，允许多个指针共享一个对象的所有权，通过控制块实现计数。

```cpp
+----------------------------+
| Control Block              |
+----------------------------+
| Shared Count (强引用计数)   | <--- 每次创建或复制一个 shared_ptr，计数加 1
+----------------------------+
| Weak Count (弱引用计数)     | <--- 每次创建或复制一个 weak_ptr，计数加 1
+----------------------------+
| Object Pointer (对象指针)   | <--- 指向实际的对象
+----------------------------+
| Deleter (删除器)            | <--- 当引用计数为 0 时调用删除器来销毁对象
+----------------------------+
```

#### `unique_ptr`

`shared_ptr` 和 `weak_ptr` 通过引用计数来管理资源，这使得资源可以有多个共享所有者。而 `unique_ptr` 通过禁止拷贝并允许移动操作来确保资源只有一个所有者。因此，它不能与其他 `unique_ptr` 实例共享资源。  

使用场景：

我在协程库中又使用到`unique_ptr`来管理我的IOManager的中`idel()`函数中的

`std::unique_ptr<epoll_event[]> events(new epoll_event[MAX_EVENTS])`，当events的生命周期结束时，它会自动调用`delete[]`来释放分配的内存，从而销毁`epoll_event`数组。另外在raft项目中，我再去引入`m_iomanager`的时候，也使用了`unique_ptr`，这里再Raft类中使用了`unique_ptr`，表明只有Raft能够拥有对于协程库的唯一控制权，`IOManager`对象不需要被其他地方引用，确保离开作用域后`IOManager`对象的正确销毁。另外，比如创建线程池的时候，只有线程池类能够拥有控制`thread`类的指针，所以也要用`unique_ptr`。

## 计算机的乱序执行

### 1. **乱序执行的背景与动机**

#### 1.1. **顺序执行的瓶颈**

传统 **顺序执行（In-Order Execution）** 按指令在程序中的顺序逐条执行，但会遇到以下问题：

- **流水线气泡（Bubble）**：当某条指令因数据未就绪（如等待内存加载）或资源冲突而阻塞时，后续指令无法执行，导致流水线空闲。
- **资源利用率低**：某些功能单元（如ALU、浮点单元）可能闲置，而其他单元过载。

#### 1.2.  **乱序执行的思路**

- **动态调度**：处理器硬件实时分析指令间的依赖关系，优先执行已就绪的指令，跳过被阻塞的指令。
- **目标**：最大化指令级并行（ILP），填满流水线，提高吞吐量。

------

### 2. **乱序执行的工作原理**

#### 2.1. **指令处理流程**

1. **取指（Fetch）**：从内存中读取指令。
2. **解码（Decode）**：解析指令，识别操作类型和操作数。
3. **重命名（Rename）**：使用 **寄存器重命名** 技术消除伪依赖（如WAR和WAW依赖）。
4. **分发（Dispatch）**：将指令存入 **保留站（Reservation Station）**，等待操作数就绪。
5. **执行（Execute）**：一旦操作数就绪，指令被发送到功能单元执行（可能乱序）。
6. **提交（Commit）**：通过 **重排序缓冲区（ROB）** 按原始程序顺序提交结果，保证逻辑正确性。

#### 2.2. **指令依赖类型**

- **真依赖（True Dependency，RAW）**：指令B需要指令A的结果，必须顺序执行。
- **反依赖（Anti Dependency，WAR）**：指令B写入指令A读取的寄存器，通过寄存器重命名解决。
- **输出依赖（Output Dependency，WAW）**：两条指令写入同一寄存器，通过重命名解决。

### 3. **代码示例与类比**

#### 3.1.  **类比：工厂流水线**

假设汽车装配线需要按顺序安装引擎、轮胎和喷漆：

- **顺序执行**：如果引擎到货延迟，整条流水线停工等待。
- **乱序执行**：在等待引擎时，先装配其他汽车的轮胎或喷漆。

#### 3.2. **伪代码依赖分析**

```z80
LOAD R1, [0x1000]  ; 从内存加载数据到R1（耗时操作）
ADD  R2, R1, R3    ; R2 = R1 + R3（依赖R1）
MUL  R4, R5, R6    ; R4 = R5 * R6（无关指令）
```

- 乱序执行会在等待`LOAD`时优先执行`MUL`。

### 4. 关于互斥锁的实现原理

互斥锁确实依赖硬件的原子操作（如 `CAS`、`TAS`）管理锁状态（0/1）。这是实现锁的基础。锁状态的修改必须通过原子操作，确保多线程环境下不会出现竞态条件（Race Condition）。当锁空闲时（原子变量为0），直接通过原子操作获取锁，时间量级为 **10~100 纳秒**。此时无需任何自旋或阻塞，仅需**一次原子操作和内存访问**。当锁被占用时，线程在用户态通过循环（自旋）尝试获取锁。自旋阶段的耗时确实在 微秒级（取决于自旋次数和 CPU 频率）。自旋是互斥锁的一种优化策略，但**并非所有互斥锁都会自旋**（例如，纯阻塞锁会直接进入内核态）。若自旋一定次数后仍未获取锁，线程会通过系统调用（如 `futex`）进入内核态，挂起并让出 CPU。上下文切换和线程调度的开销在 微秒到毫秒级（取决于操作系统负载）。若锁的**竞争策略不公平**（如无队列管理），高竞争场景下可能导致线程饥饿（某些线程长期无法获取锁）。

**自旋锁（Spinlock） 和 互斥锁（Mutex）** 的区别：

- 自旋锁完全在用户态自旋，不进入内核态（适用于极短期等待，如内核中断处理）。
- 互斥锁通常结合自旋和阻塞策略（如 Linux 的 `pthread_mutex`）。

**公平锁的实现：**

- `Ticket Lock`：通过排队机制（类似银行取号）确保先到先得。
- `MCS Lock`：每个等待线程自旋在自己的本地变量上，减少缓存一致性开销。
- `Futex `的优先级继承：Linux 通过 `FUTEX_PI` 防止优先级反转（Priority Inversion）。

## C++面向对象

### c++面向对象三大特性

继承、封装、多态

#### 封装（Encapsulation）

**定义：**将数据（属性）和操作数据的方法（函数）绑定在一个单元（类）中，对外隐藏实现细节，仅暴露接口。
**核心思想：数据隐藏**和**接口隔离**，提升安全性和可维护性。

**C++实现：**

- 使用`private`/`protected`限制数据直接访问。
- 通过`public`方法提供可控的读写接口。

#### 继承（Inheritance）

**定义：**允许一个类（派生类）基于另一个类（基类）构建，继承其属性和方法，并可扩展或重写功能。
**核心思想：**代码复用和层次化建模，建立类之间的“is-a”关系。

**C++实现：**

- 使用`class Derived : public Base`语法。
- 支持公有、保护、私有继承（默认私有继承）。

#### 多态（Polymorphism）

**定义**：同一操作作用于不同对象时，可产生不同的行为。
**核心思想**：接口统一，实现各异，分为编译时多态和运行时多态。

- **编译时多态（静态绑定）**

- **函数重载**：同一作用域内同名函数，参数不同。
- **模板**：泛型编程。

- **虚函数**

- 通过vptr、vtable实现

### C++中的虚函数

#### 1.1.  **虚函数表（vtable）**

- **定义**：每个包含虚函数的类（或从含虚函数的类派生的类）都有一个**虚函数表**。
- **结构**：

- 虚函数表是一个函数指针数组，每个元素指向类的虚函数实现。
- 若类有多个虚函数，它们在表中按声明顺序排列。
- 若类继承自基类，基类的虚函数在表中优先排列，派生类的新虚函数紧随其后。

- **示例**：

```cpp
class Base {
public:
    virtual void func1() {}    // 虚函数1
    virtual void func2() {}    // 虚函数2
};

class Derived : public Base {
public:
    void func1() override {}   // 重写基类虚函数1
    virtual void func3() {}    // 新增虚函数3
};
```

- `Base` 的虚函数表：`[&Base::func1, &Base::func2]`
- `Derived` 的虚函数表：`[&Derived::func1, &Base::func2, &Derived::func3]`

------

#### 1.2.  **虚函数表指针（vptr）**

- **定义**：每个对象实例的内存起始位置（或特定位置）包含一个隐藏指针 **vptr**，指向其类的虚函数表。
- **初始化**：

- 在对象构造时，构造函数会设置 vptr 指向当前类的虚函数表。
- 派生类构造函数会先调用基类构造函数（此时 vptr 指向基类虚函数表），随后再更新为派生类的虚函数表。

- **内存布局**：

```cpp
Derived obj;
// 内存结构（简化）：
+----------------+
| vptr           | --> 指向 Derived 的虚函数表
| Base 成员变量   |
| Derived 成员变量|
+----------------+
```

------

#### 1.3. **虚函数调用过程**

当通过基类指针或引用调用虚函数时，编译器生成如下代码：

1. 通过对象的 **vptr** 找到虚函数表。
2. 根据函数在虚函数表中的**偏移量**（编译时确定）找到函数地址。
3. 调用该地址对应的函数。

- **示例**：

```cpp
Base* ptr = new Derived();
ptr->func1(); // 实际调用 Derived::func1()
```

- 汇编伪代码：

```z80
mov rax, [ptr]        ; 获取对象地址
mov rax, [rax]        ; 获取 vptr（对象首地址）
call [rax + 0]        ; 调用虚函数表中第一个函数（func1）
```

------

#### 1.4.  **多继承下的虚函数表**

- **多个虚函数表**：若派生类继承多个含虚函数的基类，每个基类对应独立的虚函数表。
- **vptr 数量**：派生类对象会有多个 vptr，分别指向不同基类的虚函数表。
- **调整 this 指针**：当通过第二个基类指针调用派生类函数时，需调整 this 指针偏移量。
- **示例**：

```cpp
class Base1 { virtual void f1(); };
class Base2 { virtual void f2(); };
class Derived : public Base1, Base2 {
    void f1() override {}
    void f2() override {}
};

Derived obj;
Base1* b1 = &obj; // vptr 指向 Base1 的虚函数表
Base2* b2 = &obj; // vptr 指向 Base2 的虚函数表（偏移量在对象内存中）
```

------

#### 1.5. **虚析构函数**

- **必要性**：若类可能被多态使用（通过基类指针删除对象），基类析构函数必须为虚函数。
- **实现**：

- 虚析构函数会被加入虚函数表。
- 调用析构函数时，通过虚函数表找到实际派生类的析构函数，确保正确释放资源。

- **示例**：

```cpp
class Base {
public:
    virtual ~Base() {} // 虚析构函数
};

class Derived : public Base {
public:
    ~Derived() override {} // 析构函数自动成为虚函数
};

Base* ptr = new Derived();
delete ptr; // 正确调用 Derived::~Derived()
```

------

#### 1.6.  **纯虚函数与抽象类**

- **纯虚函数**：虚函数声明为 `= 0` 时是纯虚函数，要求派生类必须实现。
- **虚函数表条目**：纯虚函数在虚函数表中通常指向一个占位函数（如 `pure_virtual_called`），若未实现会触发运行时错误。
- **示例**：

```cpp
class AbstractBase {
public:
    virtual void func() = 0; // 纯虚函数
};

class Concrete : public AbstractBase {
public:
    void func() override {} // 必须实现
};
```

------

#### 1.7. **运行时开销**

- **空间开销**：

- 每个对象多一个 vptr（通常 8 字节，64 位系统）。
- 每个类多一个虚函数表。

- **时间开销**：

- 虚函数调用需通过 vptr 间接寻址（多一次指针跳转）。
- 无法内联虚函数（除非编译器能确定具体类型，如 `final` 类）。

- **虚函数表（vtable）** 存储类的虚函数地址。
- **虚函数表指针（vptr）** 位于对象内存起始位置，指向虚函数表。
- 虚函数调用通过 vptr 间接寻址，实现动态绑定（运行时多态）。
- 多继承和虚继承会引入额外的虚函数表和 this 指针调整逻辑。
- 虚析构函数确保正确调用派生类析构函数，避免资源泄漏。

此机制是 C++ 实现多态的核心，理解它对调试内存问题、性能优化和复杂继承设计至关重要。

### 单继承多继承

#### 虚函数表（vtable）的规则

**每个类独立拥有虚函数表**：无论继承深度如何，每个类（包括基类和派生类）都有自己的虚函数表。

虚函数表内容：

**单继承**：派生类虚函数表继承基类的虚函数表，覆盖的虚函数替换地址，新增的虚函数追加到表尾。

```plain
+----------------+
| vptr           | --> 指向第 100 层类的虚函数表
| 基类成员变量     |
| ...            |
| 第 100 层成员变量|
+----------------+
```

**多继承：**每个基类对应独立的虚函数表，派生类可能合并或扩展这些表。

```plain
+----------------+
| Base1 的 vptr   | --> 指向 Derived 中 Base1 的虚表
| Base1 成员变量   |
| Base2 的 vptr   | --> 指向 Derived 中 Base2 的虚表
| Base2 成员变量   |
| Derived 成员变量 |
+----------------+
```

### 虚函数和纯虚函数的区别

**虚函数**

- 虚函数是在一个基类中声明成`virtual`的成员函数，它允许通过基类指针或者引用来调用派生类中的重写函数。
- 它可以被重写，因为这个函数在基类中定义，在派生类中重写。
- 如果派生类中没有重写这个函数，调用时会使用基类中的实现，运行的时候通过基类指针或引用调用虚函数时，实际调用的是派生类中重写的版本。

**纯虚函数**

- 纯虚函数不能在基类中提供实现，他仅仅作为接口存在
- 派生类中必须重写纯虚函数，否则派生类也将成为抽象类，不能实例化
- 含有纯虚函数的类称为抽象类，抽象类无法直接实例化，只能作为基类供派生类继承。

### C++中的多继承问题

c++中的是可以支持多继承的，在这方面python也支持，但是java以及c语言是不支持多继承的。他们只能有单继承，多继承的好处就能够灵活，继承多个类的成员函数和成员变量，但是多继承也带来了不安全性，比如继承的两个类都存在相同的成员函数，那么子类该调用哪个会产生歧义问题，另外就是菱形继承的问题。但是解决这个问题可以使用虚继承。

- **如果说二义性的话只能通过作用域来解决。**
- **虚继承只是能够解决基类中只有一份实例的问题。**

#### 虚函数调用性能

**与继承深度无关：**
虚函数调用的跳转次数固定为两次（访问 `vptr` → 访问虚函数表），无论继承链是 1 层还是 100 层。

**唯一开销：**
间接寻址可能导致分支预测失败或缓存未命中，但这是所有虚函数的共有开销，与继承深度无关。

#### 多继承的复杂性

**多个 vptr：**
多继承的对象可能包含多个 `vptr`，分别指向不同基类的虚函数表。

**this 指针调整：**
通过不同基类指针调用虚函数时，可能需要调整 `this` 指针的偏移量（由编译器自动处理）。

### 是否可以`delete this`

可以但是要满足以下三个条件：

- **对象必须通过** `new` **分配在堆上：**

- 如果对象是栈对象、全局对象或类成员对象，`delete this` 会导致未定义行为（UB）（如程序崩溃或内存损坏）。

- **调用** `delete this` **后，必须立即停止使用该对象**：

- 在 `delete this` 之后，任何对成员变量或成员函数的访问（包括隐式的 `this` 指针解引用）都是非法的。

- **不能在析构函数中调用** `delete this`**：**

- 析构函数本身由 `delete` 触发，递归调用会导致堆栈溢出。

### 如果一个空类，他会默认添加哪些函数？

```cpp
class Empty{
    Empty();     //默认构造
    Empty(const Empty&); //拷贝构造函数
    Empty& operator=(const Empty&); //赋值运算符
    ~Empty()    //默认析构函数
};
```

## C++多线程无锁编程

### memory_order_relaxed等关键字

```
memory_order_relaxed
```

仅保证原子操作的原子性，不提供任何内存顺序或同步约束。允许编译器和处理器对操作进行重新排序，其他线程可能无法立即看到操作的顺序。

- 适用于需要原子操作但不依赖其他内存操作的顺序时（如计数器、统计值）
- 多线程共享变量但无需同步其他数据的情况。

```
memory_order_acquire
```

用于**加载（load）**操作确保当前操作之后的所有读写不会被重新排到该操作之前。与`memory_order_release`配对使用，建立同步关系，保证其他线程的写入可见性。适用于需要读取共享数据并确保看到之前线程的所有修改时（加锁的获取、标志位检查）。

```
memory_order_release
```

用于 **存储（store）**操作，确保当前操作之前的所有读写不会被重排到该操作之后。与`memory_order_acquire`配对使用，实现线程间同步。

- 在更新共享数据后通知其他线程（如解锁、发布数据）。在C++多线程编程中，`memory_order_acquire`、`memory_order_relaxed`等内存顺序参数用于控制原子操作的内存访问顺序和可见性。以下是它们的详细说明及使用场景：

```
memory_order_seq_cst
```

- 提供 **顺序一致性**，所有线程看到的操作顺序一致，但性能开销较大。  
- 所有`seq_cst`操作形成一个全局顺序。

- 需要强一致性保证的复杂同步场景。  
- 当不确定选择哪种内存顺序时，作为保守选项。

| 内存顺序               | 操作类型      | 同步保证               | 性能开销 |
| ---------------------- | ------------- | ---------------------- | -------- |
| `memory_order_relaxed` | 任意          | 仅原子性               | 最低     |
| `memory_order_acquire` | 加载（load）  | 防止后续操作重排到前面 | 中       |
| `memory_order_release` | 存储（store） | 防止前面操作重排到后面 | 中       |
| `memory_order_seq_cst` | 任意          | 全局顺序一致性         | 最高     |