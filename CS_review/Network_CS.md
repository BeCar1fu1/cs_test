```shell
+------------------------------------------------------+
| 请求行(Request Line)                                 |
|  GET /index.html HTTP/1.1                            |
+------------------------------------------------------+
| 请求头部(Request Headers)                            |
|  Host: www.example.com                               |
|  User-Agent: Mozilla/5.0                             |
|  Accept: text/html                                   |
|  Accept-Encoding: gzip, deflate                      |
|  Connection: keep-alive                              |
+------------------------------------------------------+
| 空行 (CRLF, \r\n)                                    |
+------------------------------------------------------+
| 请求体 (Body，可选)                                  |
|  username=alice&password=123456                      |
+------------------------------------------------------+
```

HTTP响应报文结构

```shell
+------------------------------------------------------+
| 状态行(Status Line)                                  |
|  HTTP/1.1 200 OK                                     |
+------------------------------------------------------+
| 响应头部(Response Headers)                           |
|  Date: Tue, 10 Sep 2024 12:00:00 GMT                 |
|  Server: nginx/1.18.0                                |
|  Content-Type: text/html; charset=UTF-8              |
|  Content-Length: 1024                                |
|  Cache-Control: max-age=3600                         |
|  Set-Cookie: SESSIONID=xyz123; Path=/; HttpOnly      |
+------------------------------------------------------+
| 空行 (CRLF, \r\n)                                    |
+------------------------------------------------------+
| 响应体 (Body，可选)                                  |
|  <html>                                              |
|    <head><title>Hello</title></head>                 |
|    <body>Hello, world!</body>                        |
|  </html>                                             |
+------------------------------------------------------+
```

### HTTP的状态码

 HTTP 状态码分为五类：1xx 信息、2xx 成功、3xx 重定向、4xx 客户端错误、5xx 服务器错误。常见的有 200（成功）、301/302（重定向）、304（未修改）、400（坏请求）、401（未授权）、403（禁止）、404（未找到）、500（服务器内部错误）、502（网关错误）、503（服务不可用）。

### HTTP1.1怎么对请求做拆包，具体来说怎么拆的？

当服务器无法预先确定响应体的总大小时（例如实时生成的数据流），会使用 `Transfer-Encoding: chunked` 头部，将响应体拆分为多个**块（chunk）**逐个发送。每个块包含两部分：

1. **块大小**（16进制数字，如 `1F4` 表示500字节）。
2. **块数据**（实际内容）。

```plain
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked  # 关键头：启用分块传输

1F4                       # 第1块大小：500字节（16进制的1F4）
[这里是500字节的日志数据...]
2BC                       # 第2块大小：700字节（16进制的2BC）
[这里是700字节的日志数据...]
0                         # 最后一块大小为0，表示结束
```

具体来说，当客户端发送一个HTTP请求时，会在请求头中添加"Content-Length"字段，该字段的值表示请求正文的字节数。服务器在接收到请求后，会根据"Content-Length"字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。这种基于"Content-Length"字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。

### HTTP 断点重传是什么?

### HTTPS的握手以及中间人攻击？

## TCP/IP内容

### TCP的头格式有哪些？

TCP的头部大小在20~60字节，包含源端口号、目的端口号、序列号、确认应答号、控制位、窗口大小、首部字段、校验和等等。

- **序列号**：在建立连接时由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。**用来解决数据包乱序的问题。**
- **确认应答号：**指下一次期望接收到的数据的序列号，发送端收到这个确认应答以后可以任务这个序列号以前的数据都已经被正常接收。**用来解决丢包的问题。**

### TCP层的作用

TCP是一个工作在**传输层**的**可靠数据传输服务**，她能够确保接收端接受的网络包是**无损坏、无间隔、非冗余和按序的。**

- **无损坏：**靠**校验和**保证数据在传输过程中不会损坏。
- **无间隔：**靠**确认应答机制和超时重传机制**，保证丢包后能够自动重传。
- **非冗余：**靠**序列号**保证不会重复交付同一份数据。
- **按序：**靠**序列号和接收端缓存**，保证数据按发送顺序交付数据

### TCP的三次握手可以携带数据吗？

前两次不可以，因为连接还没有建立，所以双方还未群人对方的接受能力，只能第三次握手之后，上方都进入了ESTABLISHED状态，才可以，但通常不这么做， RFC  标准规定的，简化实现，避免安全隐患，兼容老版本。

### 如何在 Linux 系统中查看 TCP 状态？

使用`netsat-napt`

### 为什么是三次握手而不是两次握手？

1. 三次握手才可以组织重复历史连接的初始化。
2. 三次握手才能同步双方的初始序列号。
3. 残次握手才可以避免资源浪费。

### ping中返回的ttl是指什么？  

- 每个 IP 数据包在报头里都有一个 **TTL 值**，它是一个 8 位字段（最大 255）。
- 当数据包经过一个路由器时，TTL 会 **减 1**。
- 如果 TTL 减到 **0**，路由器就会丢弃这个包，并返回一个 ICMP 超时报文（“Time Exceeded”）。

👉 设计这个机制的目的：**防止数据包在网络里无限循环**。

### Nagle算法

 Nagle 算法的作用是减少 TCP 小包的发送，通过把小数据缓存合并成大报文再发，解决“频繁发送 tiny packet 浪费带宽”的问题。但它会引入延迟，所以在低延迟交互场景（游戏、即时通信）里通常会关闭。  

### TCP全连接队列和半连接队列

**全连接队列取决于**`**min(somaxconn,backlog)**`

- `somaxconn `是Linux内核的参数，默认值是128，可以通过`/proc/sys/net/core/somaxconn`来设置其值。
- `backlog`是`listen(int sockfd,int backlog)`函数中的`backlog`大小，Nginx默认值是511，而可以通过修改配置文件设置其长度。

**半连接队列**

```plain
if (半连接队列满){
    没有开启tcp_syncookies，则会丢弃连接;
}
if(全连接队列满，且没有重传SYN+ACK包的连接请求多于1个){
    丢弃;
}
if(没有开启tcp_syncookies && (max_syn_backlog-当前半连接队列长度)<(max_syn_backlog)>>2){
    丢弃;
}
1. 全连接队列最大值 = min(somaxconn, backlog)
   - 需同时调整内核参数和应用配置。

2. 半连接队列最大值计算：
   - 步骤1：计算 min(somaxconn, backlog)
   - 步骤2：比较 tcp_max_syn_backlog 和步骤1结果：
     - 若 tcp_max_syn_backlog > min(somaxconn, backlog) → max_qlen_log = min(somaxconn, backlog) * 2
     - 否则 → max_qlen_log = tcp_max_syn_backlog * 2
   - 步骤3：max_qlen_log 是移位位数，队列最大值 = 2^max_qlen_log（如256对应max_qlen_log=8）

3. 内核的额外限制：
   - 即使队列未达最大值，若当前长度 > (max_syn_backlog - max_syn_backlog/4)，仍会丢弃SYN包。
   - 这是实际观察值（如193）可能小于理论值（256）的原因。
```

### 关于tcp_syncookies 如何绕过半连接队列的限制？它的工作原理是什么？

- 核心功能：在半连接队列（SYN队列）满时，绕过队列限制，允许合法连接建立。
- 适用场景：防御 SYN洪泛攻击（攻击者发送大量SYN包占满队列，导致正常连接无法建立）。

`tcp_syncookies` 0表示关闭这个功能，1表示只有在半连接队列满时开启这个功能，2表示时刻开启这个功能，原理就是服务端根据当前的状态计算一个值，放在己方发送的SYN+ACK报文中，当客户端返回ACK报文时，取出该值验证，如果合法，就认为连接建立成功，从而绕过了半连接队列

### TCP第一次握手的SYN包在传输过程中丢失，客户端和服务端会如何应对？

**客户端**

- **超时重传机制：**当客户端发送SYN包后未收到服务端的SYN-ACK响应，会触发超时重传机制。
- **重传次数限制：**由内核参数 tcp_syn_retries 控制，默认值为 5次。
- **超时时间变化：**每次重传的RTO（超时时间）呈指数增长：
- **终止条件：**达到最大重传次数后，客户端放弃连接并返回错误。

**服务端行为（被动接收方）**

- **无响应：**由于SYN包未到达服务端，服务端不会触发任何动作（如未收到SYN包，服务端不会进入SYN_RECV状态）。

### TCP 第二次握手的 SYN+ACK 包丢失时，客户端和服务端会如何应对？

当 TCP 第二次握手的 SYN+ACK 包丢失时，由于通信双方都不能确定是不是对方的包丢失了，**客户端会因未收到确认而超时重传 SYN 请求**，根据内核参数tcp_syn_retries确定重传次数，间隔时间呈指数退避。而服务端在未收到第三次握手的 ACK 包时，也会触发超时重传机制多次（`tcp_synack_retries` ）重发 SYN+ACK 包；若双方在最大重传次数内仍无法建立连接，服务端会关闭半连接状态，客户端最终放弃连接并返回错误。

### TCP 第三次握手的 ACK 包丢失时，客户端和服务端会进入什么状态？如果客户端后续尝试发送数据，连接会如何演变？

当TCP第三次握手的ACK包丢失时，**服务端**因未收到ACK，会持续重传SYN+ACK包，重传次数由内核参数 `tcp_synack_retries`（默认5次）控制，超时时间按指数退避（如1s→3s→7s→15s→31s）。若最终未收到ACK，服务端关闭连接并释放资源，状态从 `SYN_RCVD` 回到 `CLOSED`。  

**客户端**则认为连接已建立（处于 `ESTABLISHED` 状态），后续发送数据时：  

1. **数据包重传**：客户端发送的数据包若未被服务端确认，会触发超时重传机制，由 `tcp_retries2`（默认15次）控制。  
2. **服务端响应**：若服务端已关闭连接，会返回RST报文强制中断连接；若服务端仍存活但未建立连接，数据包被丢弃，客户端最终因重传超时断开连接。  
3. **保活机制（Keep-Alive）**：若连接长期空闲，客户端会发送保活探测包（默认时间由 `tcp_keepalive_time` 控制），若多次无响应（`tcp_keepalive_probes`），则主动断开。

**实验三验证**：ACK丢失后，服务端重传SYN+ACK至上限后关闭，客户端发送数据触发服务端RST或自身超时，最终双方连接终止。

### TCP 的快速重传和选择性确认（SACK）机制是如何协同工作的？

对于快速重传机制，比如客户端持续发送了六个数据包，当地3个数据包因为某些原因产生丢包或者没有按时到达，服务端会一直发送“确认收到数据包2”的信息，当发生三次ACK就认为数据包3丢失，客户端则立即进行数据包3的重传，如果三次握手时协商了SACK机制，那么只需要重传数据包3就可以了，如果没有协商，就需要重传3、4、5、6数据包。、

### TCP流量控制中，如果接收方通告窗口大小变为0（零窗口），发送方会如何应对？

如果接收方通知窗口大小为0，那么发送方会发送窗口探测报文进行定时探测，探测时间每次翻倍。探测报文可能是 携带1字节数据的报文（尝试触发ACK）或 纯ACK报文。

### 在TCP零窗口探测场景中，窗口探测报文与TCP保活探测报文（Keep-Alive）有何区别？

- **触发条件**：零窗口探测在接收方窗口为0时触发，用于恢复数据传输；保活探测在连接长期无数据交互时触发（默认2小时），用于检测对端存活状态。
- **报文内容**：零窗口探测可能携带1字节数据（尝试触发ACK）或为纯ACK；保活探测为无数据的纯ACK报文。
- **内核参数**：零窗口探测重试次数由 `tcp_retries2`（默认15次）控制；保活探测通过 `tcp_keepalive_time`（探测开始时间）、`tcp_keepalive_intvl`（探测间隔）、`tcp_keepalive_probes`（探测次数）管理。
- **设计目的**：零窗口探测解决接收方缓冲区满导致的传输阻塞；保活探测解决长时间空闲连接的假存活问题。

### TCP 拥塞控制中，慢启动（Slow Start）和拥塞避免（Congestion Avoidance）阶段的阈值（ssthresh）如何动态调整？

在TCP拥塞控制中，慢启动阶段的阈值（ssthresh）初始值较高，拥塞窗口（cwnd）呈指数增长；当发生超时重传时，ssthresh会被更新为当前cwnd的一半，cwnd重置为1，重新进入慢启动，表明网络严重拥塞。而快速重传触发时（如收到3个重复ACK），ssthresh同样设为当前cwnd的一半，但cwnd降为ssthresh+3*MSS，进入快速恢复阶段，逐步线性增长，避免完全重置窗口。两者的核心差异在于：超时重传会彻底重置cwnd（激进降速），快速重传则保留部分窗口（温和降速），以区分网络拥塞程度。

### 在 TCP 三次握手的客户端优化中，参数 `tcp_syn_retries` 的作用是什么？默认值是多少？如果客户端在网络稳定的内网环境中，应如何调整此参数以优化性能？

`tcp_syn_retries` 控制客户端 SYN 报文的重传次数，默认值为 5 次，每次超时时间指数退避。在内网等稳定环境中，可降低此值（如 2-3 次）以减少连接建立延迟。

------

### 当服务端的 SYN 半连接队列溢出时，可以通过哪些内核参数调整队列大小？除了调整队列大小，还可以通过什么机制避免因队列溢出导致连接失败？

调整 `tcp_max_syn_backlog`、`somaxconn` 和应用程序的 `backlog` 可增大 SYN 半连接队列。若队列溢出，可启用 `tcp_syncookies=1`，通过加密 Cookie 验证客户端身份，无需队列即可建立连接。

------

### 在 TCP 四次挥手中，TIME_WAIT 状态为什么需要保持 2MSL（60 秒）的时长？列举两种优化 TIME_WAIT 状态的方案，并解释其适用场景和潜在风险。

TIME_WAIT 保持 2MSL（60 秒）防止旧连接数据错乱和确保被动方正确关闭。优化方案：1) 增大 `tcp_max_tw_buckets` 限制 TIME_WAIT 数量；2) 客户端启用 `tcp_tw_reuse` 复用端口（需开启时间戳）。



### 如何通过 `ss` 命令和 `netstat` 命令分别观察服务端的全连接队列（accept 队列）状态和溢出情况？如果发现全连接队列频繁溢出，应如何调整相关参数？

`ss -ltn` 查看 Send-Q（全连接队列最大值）和 Recv-Q（当前等待数）；`netstat -s` 统计 overflowed 次数。队列溢出时需增大 `somaxconn` 和应用程序的 `backlog`。



### TCP Fast Open（TFO）技术如何绕过三次握手以提升性能？请描述其首次连接和非首次连接的工作流程，并说明在 Linux 系统中如何启用 TFO 功能。

TFO 通过 Cookie 机制绕过三次握手：首次连接正常握手并缓存 Cookie；后续连接在 SYN 携带 Cookie 和数据，服务端验证后直接响应数据。Linux 启用需设置 `tcp_fastopen=3`（客户端和服务端支持）。



### 在 TCP 数据传输优化中，“带宽时延积”（BDP）的定义是什么？如何根据 BDP 调整发送缓冲区和接收缓冲区的大小？列举相关的 Linux 内核参数及其作用。

BDP = 带宽 × RTT，表示网络最大可承载数据量。发送/接收缓冲区应接近 BDP，通过 `tcp_wmem`、`tcp_rmem` 动态调整，避免 `SO_SNDBUF/SO_RCVBUF` 固定值破坏自适应。



### 被动关闭方出现大量 CLOSE_WAIT 状态的可能原因是什么？

大量 CLOSE_WAIT 因被动方未调用 `close()` 释放连接，需检查应用程序逻辑（如未处理 read 返回 0 或异常关闭）。系统层面无直接参数，需修复代码。

被动放如果想感知到FIN：

- `recv()`返回0，说明连接关闭，则调用`close()`。
- epoll的`EPOLLHUB/EPOLLDHUP`，事件触发表示对方关闭
- `getsockopt(TCP_INFO)`，可以轮询tcp.infortcpi.state是否是CLOSE_WAIT
- SO_KEEPALIVE系统级探测死链接，长时间无数据则关闭。

### 参数 `tcp_abort_on_overflow` 的作用是什么？在什么场景下应将其设置为 1？为什么默认建议设置为 0？

`tcp_abort_on_overflow=1` 时，全连接队列满则发送 RST 通知客户端连接失败。默认 0（静默丢弃 ACK），适用于突发流量；设为 1 仅用于调试队列溢出问题。当确定大量的连接是由于全连接队列溢出而失败时，可以设置为1，这样就能够使服务端直接发送RST来直接终止连接，否则采用0，这样的话，客户端会不断的发送SYN请求包，等内核有空闲队列连接客户端时，可以进行正常连接。



### 四次挥手中收到乱序的FIN包会如何处理？

1. **加入乱序队列：**乱序的FIN报文会被暂存到内核的乱序队列（红黑树结构）。
2. **等待有序数据包：**当后续收到预期的有序数据包时，系统会检查乱序队列中是否存在连续的序列号报文。
3. **触发状态转换：**若乱序队列中的报文包含FIN标志且序列号连续，则调用`tcp_fin()`函数，将状态从`FIN_WAIT_2`转为`TIME_WAIT`。

### 在 TCP 正常挥手过程中，处于 TIME WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么?

如果双方开启了时间戳机制:

- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**大**，并且SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**大**。那么就会重用该四元组连接，跳过 2MSL 而转变为SYN RECV 状态，接着就能进行建立连接过程。
- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。那么就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST报文给服务端。

### 在 TIME WAIT 状态，收到 RST 会断开连接吗?

如果:net.ipv4.tcp_rfc1337 参数为 0，则提前结束 TIME WAIT 状态，释放连接。

如果net.ipv4.tcp_rfc1337 参数为 1，则会丟掉该 RST 报文。

### 如果客户端在 TIME_WAIT 状态下快速复用了相同四元组的连接，此时网络中残留的旧连接的延迟报文抵达了客户端，会发生什么？

当客户端启用 `tcp_tw_reuse` 并快速复用 `TIME_WAIT`连接时，残留的旧连接延迟报文可能因序列号落在新连接的接收窗口内而被接收。此时，时间戳机制的作用如下：

1. 时间戳比较：
   内核会检查报文的时间戳（`TSval`）是否大于服务端记录的最近时间戳（`ts_recent`）。若时间戳更小，说明该报文属于旧连接，直接丢弃。
2. PAWS 机制：
   即使旧报文的序列号因回绕（32位用尽后循环）恰好在新连接的接收窗口内，其时间戳必然小于新连接的初始时间戳，PAWS 会将其判定为过期报文并丢弃。
3. tcp_tw_reuse 的严格条件：
   内核要求新连接的初始时间戳必须严格大于旧连接最后一次通信的时间戳。这确保新连接的时间戳足够“新”，旧连接的延迟报文无法通过时间戳校验。

### TCP连接建立与`**accept()**`的关系

即使服务端没有启用`accept()`，TCP的三次握手仍然可以完成，连接正常建立。服务端未执行`accept()`,客户端的连接建立后，仍然可以发送数据（服务端会回复ACK确认）。`accpet()`的作用是从全连接队列中取出建立的连接。

### 为什么需要 `**accept()**`，即使连接已建立且能发送数据？

`accept()`的核心作用是从全连接队列中取出已经建立好的连接，供服务端使用。全连接队列有固定的大小。（由 `listen(fd, backlog)` 的 `backlog` 参数和系统配置共同决定）如果队列满了，不及时进行`accept（）`会导致队列积压，新来的连接服务进入，从而导致客户端收到RST或请求超时。并且，三次握手是由内核完成的，但是连接必须要由应用层接管后才能进行业务处理，`accept（）`会返回一个新的套接字描述符`cfd`该描述符代表一个**独立的双向通道，**即使客户端发送数据，服务端内核会回复ACK，但是数据停留在内核缓冲区，应用层无法通过`read()`读取（除非调用 `accept()` 获取 `cfd` 后操作）。

### 半连接队列（SYN队列）与全连接队列（ACCEPT队列）

- **半连接队列（SYN队列）**：

- 存储状态为`SYN_RECV`的连接（服务端收到第一次握手后加入）。
- 数据结构为**哈希表**，查找效率高（O(1)），适合频繁查询半连接。

- **全连接队列（ACCEPT队列）**：

- 存储状态为`ESTABLISHED`的连接（完成三次握手后从半连接队列转移而来）。
- 数据结构为**链表**，通过`accept()`取出连接（O(1)）。

- **队列溢出处理：**

- 全连接队列满：丢弃第三次握手的ACK包，若`tcp_abort_on_overflow=1`则发送RST。
- 半连接队列满：可能因SYN Flood攻击，启用`tcp_syncookies`可绕过队列（但牺牲部分可靠性）。

### 操作系统内核如何处理TCP/UDP协议栈的？

当网卡接收到数据包，然后数据线存放在**硬件缓冲区**或者DMA的可访问内存中，内核缓冲区是物理内存中连续的内存区域，由于数据已经到达了硬件缓冲区，因此，cpu收到网卡的中断会处理这个包，**由DMA做搬运**将数据搬运到**内核缓冲区**中。然后内核协议栈去做处理。

首先是对**链路层的以太网的MAC头**做解析，判断MAC地址是不是自己，然后交由网络层处理，检查IP头，确认目标IP，然后校验IP，再根据**协议字段TCP/UDP**分发到传输层，**TCP通过四元组**做连接查找，然后将数据放到TCP接收缓冲区，处理流量控制、滑动窗口、确认ACK等操作。如果是UDP则直接进去**UDP socket缓冲区，**内核缓冲区检测到有数据后，应用程序调用`recv()/read()`把内核缓冲区拷贝到用户缓冲区，应用程序就能在用户态处理网络层协议。

### 零拷贝是如何实现的？

零拷贝的过程就是数据来了由DMA将数据从硬件缓冲区然后搬运到内核缓冲区，这个时候发生一次数据拷贝，然后由`mmap()`将这个内存映射给用户态，用户态直接访问内存缓冲区，就不需要发生内核态到用户态的拷贝了。

如果说用`sendfile()`发送文件的话，那么数据直接从文件磁盘发送到内核缓冲区，然后直接由DMA搬运到socket缓冲区发送给网卡就行了，就**不涉及用户态的数据拷贝**了。