### Redis的数据结构是怎么样的？

对于**String**底层使用的是SDS（简单动态字符串），他代替了C字符串，支持动态扩容，访问字符串长度`O(1)`。并且二进制安全（因为结尾不依赖`\0`）。

```lua
内存布局（简化）：
+------+------+--------+--------+--------+--------+--------+--------+--------+
| len  |alloc| flags |  'h'  |  'e'  |  'l'  |  'l'  |  'o'  | '\0'   |
+------+------+--------+--------+--------+--------+--------+--------+--------+
 2B     2B     1B       buf[0]   buf[1]   buf[2]   buf[3]   buf[4]   结尾符
```

**List数据类型**的底层使用的是quicklist（双端链表+ziplist）特点就是插入和删除比较快，占内存少。

```diff
Quicklist（逻辑结构）：

+-----------+     +-----------+     +-----------+     +-----------+
|  qlNode1  | <-> |  qlNode2  | <-> |  qlNode3  | <-> |   ...     |
+-----------+     +-----------+     +-----------+     +-----------+
     |                 |                 |
     v                 v                 v
+----------+     +----------+     +----------+
| ziplist1 |     | ziplist2 |     | ziplist3 |
+----------+     +----------+     +----------+


quicklistNode（结构体）：

+------------+------------+------------+-----------+----------+-----------+
| prev ptr   | next ptr   | zl (ptr)   | size      | count    | encoding  |
+------------+------------+------------+-----------+----------+-----------+
      |            |           |
      v            v           v
    前节点       后节点      ziplist / listpack（实际数据）

ziplist 数据结构：

+----------+----------+----------+---------+---------+--------+------+
| zlbytes  | zltail   | zllen    | entry1  | entry2  | ...    | 0xFF |
+----------+----------+----------+---------+---------+--------+------+
```

整个`quicklist`是一个双向链表，每个节点是一个`quicklistNode`，每个`quickListNode`内部保存一个压缩结构

**Hash类型的数据结构**

键值对少，且字段和值都较小（默认小于 512 字节，数量小于 512）  ——**ziplist**（压缩列表）  

```sql
Hash key: user:1001

+-------------------------------------------+
| ziplist                                   |
+-------------------------------------------+
| zlbytes | zltail | zllen | field1 | val1 | field2 | val2 | ... | 0xFF |
+-------------------------------------------+
```

 每两个连续的 entry 为一组键值对：`field1 → val1`，`field2 → val2`，数据结构紧凑节省内存，但是查找效率低`O(n)`;

```sql
Hash key: user:1001

+-----------------------------+
| dict (hashtable)           |
+-----------------------------+
| bucket 0 → entry → field1:value1 → next ...
| bucket 1 → NULL
| bucket 2 → entry → field2:value2
| ... (多个桶)
```

**Set的数据结构**

`intset`适合所有元素都是整数，但是数量较少（默认<512个）

```sql
+-----------------------------+
| encoding (int16/int32/64)  |
| length = 3                 |
| contents: [1, 5, 9]        |
+-----------------------------+
```

数组是有序存储，适合二分法查找，每个元素都是整数，查找效率是`O(logn)`；

当集合中又非整数或元素数量超过阈值，Redis自动将`intset`转化成`hashtable`

```sql
+-------------------------+
| dict (hash table)      |
+-------------------------+
| "alice" => NULL         |
| "bob"   => NULL         |
| "carol" => NULL         |
+-------------------------+
```

**ZSet数据类型**

 **Zset = 哈希表（查 score） + 跳表（按 score 排序）**  

```sql
Zset

+-------------+
| dict (map)  |------> { "alice" => 100, "bob" => 80, "carl" => 120 }
+-------------+

+-------------------+
| skiplist (sorted) |---> 按 score 排序存储：bob(80) -> alice(100) -> carl(120)
+-------------------+
```

### Redis的数据库的数据结构是怎么样的？

```sql
┌──────────────────────────┐
│      Redis Server        │
│ ┌──────────────────────┐ │
│ │      databases[]      │◄──── Redis 支持多个 DB（默认 16 个）db0, db1...
│ └──────────────────────┘ │
└────────────┬─────────────┘
             │
             ▼
      ┌────────────────────────────┐
      │ redisDb (每个 DB 实例)     │
      └─────────────┬──────────────┘
                    │
                    ▼
           ┌──────────────────────┐
           │ dict dict (主键空间) │  ← 存储所有键值对
           └────────┬─────────────┘
                    │
       ┌────────────┴────────────┐
       ▼                         ▼
┌─────────────┐          ┌──────────────────┐
│ key: "user1"│          │ key: "post:rank" │
│ val: String │          │ val: Zset        │
└────┬────────┘          └─────────┬────────┘
     │                             │
     ▼                             ▼
┌─────────────┐          ┌───────────────────────┐
│ redisObject │          │ redisObject           │
│ type=String │          │ type=Zset             │
│ encoding=embstr/raw/int│encoding=skiplist+dict │
└──────┬────────┘        └────────────┬──────────┘
       │                              │
       ▼                              ▼
┌─────────────┐             ┌──────────────────────┐
│ SDS / int   │             │ dict: member → score │
└─────────────┘             └──────┬───────────────┘
                                   │
                                   ▼
                      ┌──────────────────────────┐
                      │ skiplist: 有序节点链     │
                      └──────────────────────────┘


另一些键值对可能使用其他数据类型 ↓

┌────────────┐      ┌────────────┐      ┌────────────┐
│ key: "msgs"│      │ key: "cart"│      │ key: "tags"│
│ val: List  │      │ val: Hash  │      │ val: Set   │
└────┬───────┘      └────┬───────┘      └────┬───────┘
     ▼                   ▼                   ▼
┌─────────────┐    ┌──────────────┐    ┌──────────────┐
│ quicklist   │    │ dict: field→v│    │ intset/dict  │
│ + ziplist[] │    └──────────────┘    └──────────────┘
└─────────────┘


其他模块内存结构（独立于键值空间）：
┌──────────────────────────────────────┐
│ AOF buffer / RDB buffer              │ ← 持久化用
├──────────────────────────────────────┤
│ client buffers / replication buffers │ ← 客户端、主从复制用
├──────────────────────────────────────┤
│ pub/sub、事务队列、定时器、Lua 引擎等   │
└──────────────────────────────────────┘
```

整个框架就是整个Redis有16个类似DB-0、DB-1等数据库的实例，然后每个数据库中维护一张key与redisObject的表，通过dict表来查询redisObjct对象，里面存储了数据的类型，编码，长度以及真是数据的指针等内容，通过里面的指针指向数据库中的真是存储数据。

###  Redis 为什么采用单线程模型？这种设计有何优缺点？  

 Redis 的核心网络处理、命令解析与执行采用单线程模型，是为了简化并发编程，保证数据访问的原子性和一致性。  

- **简化并发控制**：

- 单线程意味着每次只处理一个请求，避免了加锁、竞争条件等多线程同步开销，**实现简单，性能稳定**。

- **内存操作本身非常快**：

- Redis 所有数据都在内存中，CPU 并不成为瓶颈，性能瓶颈更多来自网络与 I/O 等。

- **使用 I/O 多路复用机制（如 epoll）提高并发处理能力**：

- 虽然是单线程，但可以**同时监听多个 socket**，从而并发地处理多个客户端请求。

- **Redis 的瓶颈不是 CPU，而是内存、网络带宽**：

- 对于大多数使用场景，单线程足以支撑百万级 QPS。

###  Redis 的多线程是干什么的？  

| **使用场景**                    | **线程作用**                                        |
| ------------------------------- | --------------------------------------------------- |
| AOF 重写（BGREWRITEAOF）        | 后台子进程异步执行                                  |
| RDB 快照（BGSAVE）              | 后台子进程生成快照，不影响主线程                    |
| 客户端 IO（从 Redis 6.0 开始）  | 使用 I/O 线程并发处理读写缓冲，**提升网络处理能力** |
| 集群通信、lazy-free、模块机制等 | 异步处理任务，减少主线程阻塞                        |
| Key 删除（`UNLINK`）            | 异步释放内存                                        |

### 如何避免使用del删除大key导致的线程阻塞问题？

Redis 会**立刻在主线程中同步释放 big_list_key 的内存**。如果这个 Key 特别大（如含有数百万元素的 List），则整个释放过程会占用几十毫秒甚至几百毫秒，**期间 Redis 无法处理任何其他请求**，严重影响 QPS 和延迟。  

Redis 从 4.0 开始引入了新的命令：

```
UNLINK key
```

- **与** `**DEL**` **相同，都会将 key 从数据库中移除；**
- **不同的是，**`**UNLINK**` **是异步删除的：**

- Redis 立即将 key 从键空间删除（让客户端看不到了）；
- 真正的内存释放由后台线程完成，避免阻塞主线程。

`flushdb async`、`flushall async`同理都是交由异步线程来删除数据。

### redis为什么性能好，为什么这么快？

1. **全内存操作，避免磁盘 I/O**
2. **单线程架构，避免上下文切换与锁竞争**  
3. **轻量级网络通信 + 多路复用技术**    

对于redis主要的性能瓶颈并不在于CPU，而在于内存和网络I/O。单线程处理网络请求的速度跟不上底层网络硬件的速度。 客户端命令通过 socket 发送给 Redis 服务端，由主线程通过 epoll 监听到后，分配给某个 IO 线程处理。IO 线程从 socket 中读取数据，写入服务端的输入缓冲区（`querybuf`）并解析命令。每个客户端在任意时刻只会被一个 IO 线程处理，因此同一个客户端内部命令顺序能被严格保持。命令解析后交由主线程统一串行执行，执行结果被写入客户端的输出缓冲区（`replybuf`），由 IO 线程异步发送回客户端 socket。整个过程中主线程始终非阻塞地调度 client 请求和执行命令，以实现高吞吐、低延迟的处理能力。  

### redis的IO线程都做什么事情？

🎯 Redis 的 IO 线程 **核心职责就两件事**：

**① 搬运数据（数据搬运工）**

- 从客户端的 socket 中**读取请求数据**（read）；
- 将主线程执行后的响应数据**写入 socket**（write）；
- 所以你可以记为：“**socket ←→ Redis 内部缓冲区** 的搬运工”。

**② 解析命令**

- 对读取到的数据执行 RESP 协议解析；
- 将每个命令放入该客户端的 `querybuf` 中（就是主线程用来取命令的输入队列）；
- 注意解析完不执行，只是**供主线程后续调度执行**。

### Redis缓存和本地缓存的区别？

- **本地缓存**

本地缓存就是将数据缓存在本地应用程序或者服务器上，能够加速数据的访问和响应速度，本地缓存通常使用内存作为存储介质，利用内存的高速读写性来提高数据访问速度。优势就是访问速度很快，毕竟基于内存，能够减轻网络压力，不需要做网络传输。但是缺点就在于本地可能受限于硬件资源的不足，当缓存数据量大的时候，硬件资源成为访问瓶颈。

- **分布式缓存（Redis）**

分布式缓存的好处就是能够弥补本地硬件资源受限的情况，在大规模缓存的时候能够通过多节点间的分片存储提升缓存存储数据的规模，然后通过分布式一致性协议，分布式缓存能够保证数据多个节点间的一致性。缺点就是增加了维护成本，另外多节点间无法再网络发生分区的时候，实现一致性和可用性，在就是增加了网络延迟。

### 为什么Redis比Mysql要快？

1. Redis是基于内存的，内存访问的速度快，不需要进行磁盘的读写，而Mysql数据是存储在磁盘的，所以说访问速度是慢于Redis的
2. Redis的数据结构也比较高效紧凑，底层的数据结构有SDS、Hashtable、ziplist、intset、skiplist。
3. Redis的处理架构采用的是单线程处理架构，多路复用以及类似Reactor模型的架构，主线程处理所有的请求，操作具有原子性，不涉及多线程的临界区和加锁操作，性能比较高。

### 高并发场景下，Redis单节点和Mysql单节点能够有多大的并发量？

如果缓存命中的话，4核心8g内存的配置，redis可以支撑10w的QPS；

如果缓存没有命中的话，4核心8g内存的配置，Mysql只能支撑5000左右的QPS；

### 什么是缓存雪崩、缓存击穿、缓存穿透

- **缓存雪崩：** 同一时刻大量缓存同时失效（比如都设置了 2 小时过期），造成大量请求直接访问后端数据库，**压垮数据库**，导致服务雪崩。  

- **给 key 的过期时间加随机值**， 
-  **对热点数据提前进行缓存预热或定时刷新**  

- **缓存击穿：** 某个**热点 key（访问量非常大）突然过期**，在这个 key 被重新加载前，大量请求同时穿透缓存，打到数据库。  

-  **对热点 key 设置为永久不过期（不设置 TTL）**  
- **互斥锁 / 分布式锁（mutex）机制**：

- 当发现 key 不存在时，只允许**一个线程去加载并重建缓存**
- 其余线程等待或返回旧值，避免并发打穿

- 在 key 接近过期时提前刷新  

- **缓存穿透：** 客户端请求大量**数据库中本身不存在的 key**，由于缓存中没有 → 每次都要查询数据库 → 数据库压力大  

- **布隆过滤器**：

- 用于快速判断 key 是否可能存在数据库中
- 不存在的直接拒绝访问，不走缓存

- **对不存在的数据设置空值缓存（null 缓存）**：

- 如果数据库查不到结果，也缓存一个空对象